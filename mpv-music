#!/usr/bin/env bash
# Purpose: MPV wrapper for music playback
VERSION="0.23.3"
# Auto-generated by build.sh. DO NOT EDIT THIS FILE DIRECTLY.

set -euo pipefail
# --- Configuration ---
CONFIG_DIR="$HOME/.config/mpv-music"
CONFIG_FILE="$CONFIG_DIR/mpv-music.conf"
MUSIC_INDEX_FILE="$CONFIG_DIR/music_index.jsonl"
LOG_FILE="$CONFIG_DIR/mpv-music.log"

# Default values (will be overridden by config file if it exists)
MUSIC_DIRS_DEFAULT=(
    "$HOME/Music"
)

VIDEO_OK=false
INDEXER_BIN=""
SERIAL_MODE=false
VOLUME=100
YTDLP_EJS_REMOTE_GITHUB=false
SHUFFLE_MODE=true
# Options: "playlist", "track", "no", "inf", or a number (e.g. "5")
LOOP_MODE="inf"

if command -v mpv-music-indexer >/dev/null 2>&1; then
    INDEXER_BIN="$(command -v mpv-music-indexer)"
elif [[ -x "$CONFIG_DIR/mpv-music-indexer" ]]; then
    INDEXER_BIN="$CONFIG_DIR/mpv-music-indexer"
fi

# visual setup
BANNER="\nâ•”â•â•  MPV-MUSIC  â•â•â•—\n"

# MPV_ARGS_DEFAULT=(--loop-playlist=inf --shuffle --no-video --audio-display=no --msg-level=cplayer=warn --display-tags= "--term-playing-msg='\${BANNER}'" "--term-status-msg='â–¶ \${?metadata/artist:\${metadata/artist} - }\${?metadata/title:\${metadata/title}}\${!metadata/title:\${filename}} â€¢ \${time-pos} / \${duration} â€¢ (\${percent-pos}%)'")
MPV_STATUS_MSG_DEFAULT='â–¶ ${?metadata/artist:${metadata/artist} - }${?metadata/title:${metadata/title}}${!metadata/title:${media-title}} â€¢ ${time-pos} / ${duration} â€¢ (${percent-pos}%)'
MPV_ARGS_SIMPLE=(
    --no-video
    --audio-display=no
    --msg-level=cplayer=warn
    --display-tags=
    --no-term-osd-bar
)
AUDIO_EXTS_DEFAULT="mp3 flac wav m4a aac ogg opus wma alac aiff amr"
VIDEO_EXTS_DEFAULT="mp4 mkv webm avi mov flv wmv mpeg mpg 3gp ts vob m4v"
PLAYLIST_EXTS_DEFAULT="m3u m3u8 pls"

# Ensure config directory exists
mkdir -p "$CONFIG_DIR"
# --- Log Management ---
rotate_log() {
  # Safe expansion: Default to 0 if unset
  if [[ "$FILE_LOGGING_DISABLED" == true ]] || [[ "${LOG_MAX_SIZE_KB:-0}" == "0" ]]; then return; fi

  # Check size only if file exists
  if [[ -f "$LOG_FILE" ]]; then
    local max_size_kb="${LOG_MAX_SIZE_KB:-0}"
    local current_size_kb
    current_size_kb=$(du -k "$LOG_FILE" | cut -f1)

    if [[ "$current_size_kb" -gt "$max_size_kb" ]]; then
      # wipe it clean
      : > "$LOG_FILE"

      local timestamp
      timestamp=$(date +'%Y-%m-%d %H:%M:%S')
      echo -e "[$timestamp] [DEBUG] Log file limit ($max_size_kb KB) reached. File wiped." >> "$LOG_FILE"

      if [[ "$DEBUG" == true ]]; then
          echo -e "${YELLOW}[DEBUG] Log file limit reached. File wiped.${NC}" >&2
      fi
    fi
  fi
}

# --- Colors & Printing Helpers ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# --- Verbose and Debug Mode ---
VERBOSE=false
DEBUG=false
FILE_LOGGING_DISABLED=false

# Standardized message helpers
msg_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
    if [[ "$FILE_LOGGING_DISABLED" == false ]]; then
        rotate_log
        echo -e "[$(date +'%Y-%m-%d %H:%M:%S')] [ERROR] $1" >> "$LOG_FILE"
    fi
}

msg_warn() {
    echo -e "${YELLOW}[WARN]${NC}  $1" >&2
    if [[ "$FILE_LOGGING_DISABLED" == false ]]; then
        rotate_log
        echo -e "[$(date +'%Y-%m-%d %H:%M:%S')] [WARN]  $1" >> "$LOG_FILE"
    fi
}

msg_success() {
    echo -e "${GREEN}[OK]${NC}    $1" >&2
    if [[ "$FILE_LOGGING_DISABLED" == false ]]; then
        rotate_log
        echo -e "[$(date +'%Y-%m-%d %H:%M:%S')] [OK]    $1" >> "$LOG_FILE"
    fi
}

msg_info() {
    echo -e "${BLUE}[INFO]${NC}  $1" >&2
    if [[ "$FILE_LOGGING_DISABLED" == false ]]; then
        rotate_log
        echo -e "[$(date +'%Y-%m-%d %H:%M:%S')] [INFO]  $1" >> "$LOG_FILE"
    fi
}

msg_note() {
    echo -e "${CYAN}[NOTE]${NC}  $1" >&2
    if [[ "$FILE_LOGGING_DISABLED" == false ]]; then
        rotate_log
        echo -e "[$(date +'%Y-%m-%d %H:%M:%S')] [NOTE]  $1" >> "$LOG_FILE"
    fi
}

# Helper function for verbose logging
log_verbose() {
    local message="[VERBOSE] $@"

    # Screen Output
    if [[ "$VERBOSE" == true ]]; then
        echo -e "$message" >&2
    fi

    # File Output
    if [[ "$FILE_LOGGING_DISABLED" == false ]]; then
        rotate_log
        echo -e "[$(date +'%Y-%m-%d %H:%M:%S')] $message" >> "$LOG_FILE"
    fi
}

# Helper function for debug logging
log_debug() {
    local message="[DEBUG] $@"

    # Screen Output
    if [[ "$DEBUG" == true ]]; then
        echo -e "$message" >&2
    fi

    # File Output
    if [[ "$FILE_LOGGING_DISABLED" == false ]]; then
        rotate_log
        echo -e "[$(date +'%Y-%m-%d %H:%M:%S')] $message" >> "$LOG_FILE"
    fi
}

# --- Temporary File Management ---
# Array to store all temporary files
declare -a TEMP_FILES=()

# Function to create a temporary file and track it for cleanup
create_temp_file() {
  local -n out_var=$1
  out_var=$(mktemp)
  TEMP_FILES+=("$out_var")
}

# Function to clean up all temporary files
cleanup_temp_files() {
    trap '' HUP INT TERM QUIT  # Ignore signals during cleanup

    log_debug "--- Cleanup triggered ---"

    # Only log cleanup if we actually have files to clean, to avoid spam
    if [[ ${#TEMP_FILES[@]} -gt 0 ]]; then
        log_debug "Cleaning up ${#TEMP_FILES[@]} temporary files..."
        for tmp_file in "${TEMP_FILES[@]}"; do
        if [[ -f "$tmp_file" ]]; then
            rm -f "$tmp_file"
            # Verify removal
            [[ ! -f "$tmp_file" ]] && log_debug "Removed: $tmp_file" || log_debug "Failed to remove: $tmp_file"
        fi
        done
        log_debug "--- Cleanup complete ---"
    else
        log_debug "No temporary files found."
    fi
    trap - HUP INT TERM QUIT
}
# Set up comprehensive trap for all common termination signals
# Ensure cleanup happens on ANY exit
trap cleanup_temp_files EXIT

# Force a hard exit on signals (which triggers the EXIT trap above)
trap "echo -e '\nBye Bye!'; exit 1" HUP INT TERM QUIT

# --- Update Trigger Function ---
invoke_updater() {

    if [[ -f "$CONFIG_FILE" ]]; then
        # Temporarily disable exit-on-error in case config is slightly broken
        set +e
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
        set -e
    fi
    # Lazy Dependency Check
    if ! command -v curl &>/dev/null; then
        msg_error "Cannot update: 'curl' is missing."
        msg_note "Please install curl to use the update feature."
        exit 1
    fi

    local updater_url="https://raw.githubusercontent.com/FurqanHun/mpv-music/master/mpv-music-updater"
    local local_updater="$CONFIG_DIR/mpv-music-updater"
    local current_script_path

    # robustly get the current script path
    current_script_path=$(readlink -f "$0")

    log_verbose "Fetching updater..."

    if curl -sL "$updater_url" -o "$local_updater"; then
        chmod +x "$local_updater"

        # Pass control to the updater
        # We use 'exec' so this script process ends and the updater takes over PID
        log_verbose "Launching updater..."
        exec "$local_updater" "$current_script_path"
    else
        msg_error "Failed to retrieve updater script."
        exit 1
    fi
}

# validate_index <index_file>
# Returns 0 if healthy, 1 if corrupt.
# FULL SCAN: Reads the whole file to catch errors in the middle.
validate_index() {
    local idx="$1"
    if [[ ! -s "$idx" ]]; then return 1; fi

    # "jq empty" reads the whole stream.
    # It takes <0.1s for normal libraries.
    # If ANY line is bad (middle or end), this returns 1.
    if ! jq -e . "$idx" >/dev/null 2>&1; then
        return 1
    fi

    return 0
}

# --- Helper Function: Check & Heal Index ---
ensure_index_integrity() {
    # Only run if index exists
    if [[ -f "$MUSIC_INDEX_FILE" ]]; then
        # Use validate_index (defined in utils) to check health
        if ! validate_index "$MUSIC_INDEX_FILE"; then
            msg_warn "Index corruption detected. Performing surgical repair..."

            temp_healed=$(mktemp)
            # select: Keep ONLY if it has ALL 8 required fields.
            jq -c -R 'fromjson? | select(.path and .title and .artist and .album and .genre and .mtime and .size and .media_type)' "$MUSIC_INDEX_FILE" > "$temp_healed"

            if [[ -s "$temp_healed" ]]; then
                mv "$temp_healed" "$MUSIC_INDEX_FILE"
                log_verbose "Bad lines removed, calling update_music_index"
                update_music_index
                msg_success "Index structure restored."
            else
                msg_warn "Index was too damaged to save. Rebuilding..."
                rm "$temp_healed"
                build_music_index
            fi
        fi
    fi
}

save_config_state() {
    local temp_conf
    create_temp_file temp_conf

    # ONLY delete the specific MUSIC_DIRS block range.
    # do NOT delete global orphans
    sed -e '/^MUSIC_DIRS=(/,/^)/d' \
        -e '/^MUSIC_DIRS=/d' \
        "$CONFIG_FILE" > "$temp_conf"

    {
            echo "MUSIC_DIRS=("
            for dir in "${MUSIC_DIRS_ARRAY[@]}"; do
                # we assuming the path dont contain double quotes (") inside them.
                echo "    \"$dir\""
            done
            echo ")"
        } >> "$temp_conf"

    mv "$temp_conf" "$CONFIG_FILE"

    log_verbose "Saved config state."

    # Reload to ensure memory matches disk
    reload_config_state
}

reload_config_state() {
    MUSIC_DIRS_ARRAY=()

    # prevents 'ghost' data if the file is empty/broken
    unset MUSIC_DIRS

    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"

        # Map the config variable to the script variable
        if [[ -n "${MUSIC_DIRS[*]}" ]]; then
             MUSIC_DIRS_ARRAY=("${MUSIC_DIRS[@]}")
        fi

        log_verbose "Reloaded: Found ${#MUSIC_DIRS_ARRAY[@]} dirs."
    else
        log_verbose "No config file found. Using defaults."
    fi
}

# Helper: Resolve which editor/viewer to use
resolve_editor() {
    local explicit="$1"
    local prefer_readonly="${2:-false}"

    if [[ -n "$explicit" ]]; then
        echo "$explicit"
        return
    fi

    if [[ "$prefer_readonly" == "true" ]]; then
        # Prioritize 'less' (Pager) -> 'vi' -> 'nano'
        # We ignore $EDITOR here because we don't want to edit logs by default.
        if command -v less &>/dev/null; then echo "less"
        elif command -v vi &>/dev/null; then echo "vi"
        else echo "nano"; fi
    else
        # Prioritize $EDITOR -> 'nano' -> 'vi'
        # We want the user's preferred editor here.
        if [[ -n "$EDITOR" ]]; then echo "$EDITOR"
        elif command -v nano &>/dev/null; then echo "nano"
        elif command -v vi &>/dev/null; then echo "vi"
        else echo "vi"; fi
    fi
}
# --- Create Config Function ---
# Creates the configuration file for mpv-music.
create_config() {
    local safe_simple_args
        safe_simple_args=$(printf "%q " "${MPV_ARGS_SIMPLE[@]}")
    cat <<EOF > "$CONFIG_FILE"
# mpv-music configuration file

# --- Playback Control ---
# Shuffle playlist by default? (true/false)
# (CLI flags: --shuffle / --no-shuffle)
SHUFFLE=$SHUFFLE_MODE

# Looping Behavior
# Options:
#   "playlist" - Loop the entire queue endlessly (default)
#   "track"    - Loop the current track endlessly (Repeat One)
#   "no"       - Play once and stop
#   "inf"      - Explicit infinite loop (same as playlist)
#   "5"        - Loop 5 times (any number works)
# (CLI flags: --loop, --repeat, --no-loop)
LOOP_MODE="$LOOP_MODE"

# Set to true to include video files in library scans by default.
# (Command line flag: --video-ok)
VIDEO_OK=$VIDEO_OK

# Set to true to force single-threaded indexing.
# Useful for mechanical HDDs to prevent thrashing.
# (Command line flag: --serial)
SERIAL_MODE=$SERIAL_MODE

# Default playback volume (0-100)
# You can override this per-run with --volume=50
VOLUME=$VOLUME

# Latest versions of yt-dlp need the 'ejs' component from GitHub to handle YouTube.
# If your yt-dlp is "bundled" (has everything inside), set this to "false".
# If you get playback errors, set this to "true".
YTDLP_EJS_REMOTE_GITHUB=$YTDLP_EJS_REMOTE_GITHUB

# Audio extensions (space-separated)
# These are used when --video-ok is NOT specified.
AUDIO_EXTS="$AUDIO_EXTS_DEFAULT"

# Video extensions (space-separated)
# These are added to AUDIO_EXTS when --video-ok IS specified.
VIDEO_EXTS="$VIDEO_EXTS_DEFAULT"

# Playlist extensions (space-separated)
PLAYLIST_EXTS="$PLAYLIST_EXTS_DEFAULT"

# Max log file size in Kilobytes (KB) before rotating.
# Default is 5120 (5MB).
LOG_MAX_SIZE_KB=5120

BANNER_TEXT='$BANNER'
STATUS_MSG='$MPV_STATUS_MSG_DEFAULT'

# Default MPV arguments (Bash Array - Double Quoted)
# These will be used if no other MPV args are passed on the command line.
# Example:
# MPV_DEFAULT_ARGS=(
#     --no-video
#     --audio-display=no
#     --msg-level=cplayer=warn
#     --display-tags=
#     --no-term-osd-bar
#     "--term-playing-msg=\$(tput clear)\$BANNER_TEXT"
#     "--term-status-msg=\$STATUS_MSG"
# )
MPV_DEFAULT_ARGS=(
    $safe_simple_args
    "--term-playing-msg=\$(tput clear)\$BANNER_TEXT"
    "--term-status-msg=\$STATUS_MSG"
)

# Default music directories (Bash Array - Double Quoted)
# You can add multiple paths,
# Example:
# MUSIC_DIRS=(
#   "\$HOME/Music"
#   "/mnt/my_music_drive/audio"
# )
MUSIC_DIRS=(
    "${MUSIC_DIRS_DEFAULT[*]}"
)

EOF
    log_verbose "Created default config file at $CONFIG_FILE"
}

# Check if config file exists, if not, create a default one
if [[ ! -f "$CONFIG_FILE" ]]; then
    log_verbose "Config file not found, creating default config..."
    create_config
fi

# Source the configuration file
# This will set the variables like MUSIC_DIRS, MPV_DEFAULT_ARGS, etc.
# We disable 'set -e' temporarily so a syntax error in the config doesn't crash
# the script before we can warn the user.
set +e
# shellcheck source=/dev/null
. "$CONFIG_FILE"
CONFIG_STATUS=$?
set -e

LOG_MAX_SIZE_KB="${LOG_MAX_SIZE_KB:-5120}"

if ! [[ "$LOG_MAX_SIZE_KB" =~ ^[0-9]+$ ]]; then
    msg_warn "Invalid LOG_MAX_SIZE_KB in config. Using default 5120KB (5MB)." >&2
    LOG_MAX_SIZE_KB=5120
elif [[ "$LOG_MAX_SIZE_KB" -eq 0 ]]; then
    FILE_LOGGING_DISABLED=true
    # This message will only appear if -V is on, which is fine.
    log_verbose "LOG_MAX_SIZE_KB is 0. All logging to file is disabled."
fi

ARGS_TO_KEEP+=("$1")

# --- Pre-Flight Flag Check ---
# We check these specific flags BEFORE sourcing the config file.
# This ensures that if the config file is broken (syntax error),
# you can still run --config to fix it or --update to patch the script.
for arg in "$@"; do
    case "$arg" in
        -V|--verbose) VERBOSE=true; shift;;
        --debug)
            DEBUG=true
            VERBOSE=true
            # Enable Bash Tracing
            set -x
            shift
            ;;
        --config|--config=*|--log|--log=*)
            key="${1%%=*}"
            val="${1#*=}"
            target_file=""
            read_only_mode="false"

            # Handle value extraction (Equals vs Space)
            if [[ "$val" == "$key" ]]; then
                val=""
                # Check next arg
                if [[ -n "${2:-}" && "$2" != -* ]]; then
                    val="$2"
                    shift # Eat the extra argument
                fi
            fi

            # Setup targets based on flag
            if [[ "$key" == "--config" ]]; then
                target_file="$CONFIG_FILE"
                read_only_mode="false"
            elif [[ "$key" == "--log" ]]; then
                target_file="$LOG_FILE"
                read_only_mode="true"
            fi

            # one function call handles defaults for both
            opener=$(resolve_editor "$val" "$read_only_mode")

            if [[ -f "$target_file" ]]; then
                log_verbose "Opening $target_file with $opener..."
                "$opener" "$target_file"
            else
                msg_warn "File not found: $target_file"
            fi
            exit 0
            ;;
        --remove-config|--rm-conf)
            if [[ -f "$CONFIG_FILE" ]]; then
                msg_warn "Deleting existing config: $CONFIG_FILE"
                rm "$CONFIG_FILE"
            fi
            msg_info "Config deleted."
            msg_note "Config will be regenerated on next run."
            exit 0
            ;;
        --remove-log|--rm-log)
            FILE_LOGGING_DISABLED=true
            if [[ -f "$LOG_FILE" ]]; then
                msg_warn "Deleting existing log: $LOG_FILE"
                rm "$LOG_FILE"
                msg_info "Log deleted."
            else
                msg_warn "File not found: $LOG_FILE"
            fi
            exit 0
            ;;
        --update)
            invoke_updater
            exit 0
            ;;
        -v|--version)
            echo "mpv-music v$VERSION"
            exit 0
            ;;
    esac
done

if [[ $CONFIG_STATUS -ne 0 ]]; then
    msg_error "Your configuration file ($CONFIG_FILE) has syntax errors." >&2
    msg_note "Please run 'mpv-music --config' to fix it." >&2
    exit 1
fi

if [[ "$(declare -p MUSIC_DIRS 2>/dev/null)" =~ "declare -a" ]]; then
    MUSIC_DIRS_ARRAY=("${MUSIC_DIRS[@]}")
else
    msg_error "Invalid MUSIC_DIRS in config. Please run 'mpv-music --config' to fix it." >&2
    exit 1
fi

IFS=' ' read -ra AUDIO_EXTS_ARRAY <<< "$AUDIO_EXTS"
IFS=' ' read -ra VIDEO_EXTS_ARRAY <<< "$VIDEO_EXTS"
IFS=' ' read -ra PLAYLIST_EXTS_ARRAY <<< "$PLAYLIST_EXTS"

if [[ "$DEBUG" == "true" ]]; then
    safe_simple_args=$(printf "%q " "${MPV_ARGS_SIMPLE[@]}")
    MPV_DEFAULT_ARGS=(
        $safe_simple_args
        "--term-playing-msg=$BANNER_TEXT"
        "--term-status-msg=$STATUS_MSG"
        "--msg-level=ytdl_hook=trace"
    )
    msg_warn "DEBUG MODE ENABLED"
    log_debug "--- SYSTEM INFO ---"
    log_debug "OS: $(uname -sr)"
    log_debug "MPV: $(mpv --version | head -n 1)"
    log_debug "YT-DLP: $(yt-dlp --version 2>/dev/null || echo 'NOT FOUND')"
    log_debug "FFMPEG: $(ffmpeg -version | head -n 1)"
    log_debug "Script Version: $VERSION"
    log_debug "-------------------"
fi

if [ -n "${MPV_DEFAULT_ARGS+x}" ]; then
    MPV_DEFAULT_ARGS_ARRAY=("${MPV_DEFAULT_ARGS[@]}")
else
    MPV_DEFAULT_ARGS_ARRAY=()
fi

# --- Config Management Functions ---

config_add_dir() {
    local target="$1"
    local skip_refresh="${2:-false}"

    if ! command -v realpath &>/dev/null; then
         msg_error "Missing 'realpath'. Cannot resolve path."
         exit 1
    fi
    local abs_path
    abs_path=$(realpath "$target")

    if [[ ! -d "$abs_path" ]]; then
        msg_error "Directory does not exist: $abs_path"
        return 1
    fi

    reload_config_state

    # Check for duplicates
    for d in "${MUSIC_DIRS_ARRAY[@]}"; do
        if [[ "$d" == "$abs_path" ]]; then
            msg_warn "Directory already exists: $abs_path"
            return 0
        fi
    done

    MUSIC_DIRS_ARRAY+=("$abs_path")

    save_config_state
    msg_success "Added: $abs_path"

    if [[ "$skip_refresh" != "true" ]]; then
        if command -v update_music_index &>/dev/null; then
            log_verbose "Scanning new directory..."
            update_music_index
        else
            msg_warn "Could not refresh index automatically."
        fi
    fi
    return 0
}

config_remove_dir() {
    local target="$1"
    local skip_refresh="${2:-false}"
    local abs_path
    abs_path=$(realpath "$target")

    reload_config_state

    local new_array=()
    local found=false

    # filter the array
    for d in "${MUSIC_DIRS_ARRAY[@]}"; do
        if [[ "$d" == "$abs_path" ]]; then
            found=true
            continue
        fi
        new_array+=("$d")
    done

    if [[ "$found" == false ]]; then
        msg_warn "Directory not found in config: $abs_path"
        return 1
    fi

    MUSIC_DIRS_ARRAY=("${new_array[@]}")
    save_config_state
    msg_success "Removed: $abs_path"

    if [[ "$skip_refresh" != "true" ]]; then
        if command -v update_music_index &>/dev/null; then
            log_verbose "Updating index..."
            update_music_index
        fi
    fi
    return 0
}

# --- Dependency Checks ---
if ! command -v mpv &>/dev/null || ! command -v fzf &>/dev/null; then
  msg_error "Missing dependencies. mpv-music requires:"
  msg_error "- mpv: media player (https://mpv.io)"
  msg_error "- fzf: fuzzy finder (https://github.com/junegunn/fzf)"
  msg_note "Install them and try again."
  exit 1
fi

if ! command -v yt-dlp &>/dev/null; then
  msg_warn "yt-dlp not found. URL playback might be limited."
  msg_note "Install yt-dlp (https://github.com/yt-dlp/yt-dlp/) for full URL support."
  # no exit here, cuz local file/folder playback
fi

if ! command -v ffprobe &>/dev/null; then
  msg_error "ffprobe not found. Metadata features will be unavailable."
  msg_note "ffprobe is part of the FFmpeg suite. Install FFmpeg (https://ffmpeg.org/download.html) and try again."
  exit 1 # cuz metadata is a core feature
fi

if ! command -v jq &>/dev/null; then
  msg_error "jq not found. Metadata indexing and advanced features will be unavailable."
  msg_note "Install jq (e.g., sudo apt install jq or brew install jq) for full functionality."
  exit 1 # index file is json, so need jq for parsing metadata
fi

if ! command -v mediainfo &>/dev/null; then
  msg_warn "mediainfo not found. Metadata extraction for some files (e.g., certain Opus) might be limited."
  msg_note "Install mediainfo (e.g., sudo apt install mediainfo or brew install mediainfo)."
fi

if ! command -v find &>/dev/null; then
    msg_error "'find' command is missing."
    exit 1
fi

if ! find . -maxdepth 0 -print0 &>/dev/null; then
    msg_error "Your 'find' command does not support -print0."
    msg_note "mpv-music requires GNU find or a compatible version for safety."
    exit 1
fi
# Cross-platform stat helpers
get_mtime() { stat -c %Y "$1" 2>/dev/null || stat -f %m "$1" 2>/dev/null; }
get_size() { stat -c %s "$1" 2>/dev/null || stat -f %z "$1" 2>/dev/null; }

# --- Helper: Pure Bash JSON Escaping ---
# Replaces jq for simple object creation.
json_escape() {
    local s="$1"
    s="${s//\\/\\\\}"
    s="${s//\"/\\\"}"
    s="${s//$'\n'/\\n}"
    s="${s//$'\r'/}"
    s="${s//$'\t'/\\t}"
    printf '%s' "$s"
}

# --- Build Extension Filter Function ---
# Builds the 'find' extension filter based on script settings
build_ext_filter() {
  local current_exts=()
  if [[ -n "$CUSTOM_EXTS" ]]; then
    IFS=',' read -ra current_exts <<< "$CUSTOM_EXTS"
  elif [[ "$VIDEO_OK" == true ]]; then
    current_exts=("${AUDIO_EXTS_ARRAY[@]}" "${VIDEO_EXTS_ARRAY[@]}" "${PLAYLIST_EXTS_ARRAY[@]}")
  else
    current_exts=("${AUDIO_EXTS_ARRAY[@]}" "${PLAYLIST_EXTS_ARRAY[@]}")
  fi

  # Clear the global EXT_FILTER before rebuilding
  EXT_FILTER=()
  for i in "${!current_exts[@]}"; do
    EXT_FILTER+=( -iname "*.${current_exts[$i]}" )
    if [[ $((i+1)) -lt ${#current_exts[@]} ]]; then
      EXT_FILTER+=( -o )
    fi
  done
}

# --- Metadata Extraction Function ---
# get_audio_metadata <file_path>
# Outputs: title,artist,album,genre (comma-separated, empty if not found)
# Example: "Song Title,Artist Name,Album Name,Genre Type"
get_audio_metadata() {
  local file="$1"

  local file_ext="${file##*.}"
    file_ext="${file_ext,,}"

    # if the file is a playlist first
    if [[ " ${PLAYLIST_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
      local title
      title="$(basename "$file" | sed 's/\.[^.]*$//')"
      # Return special metadata for playlists
      echo -e "${title}\tPlaylist\tPlaylists\tPlaylist"
      return 0
    fi

  local title=""
  local artist=""
  local album=""
  local genre=""
  local metadata_json

  # --- Attempt 1: Use ffprobe ---
  log_debug "using ffprobe!"
  metadata_json=$(timeout 2s ffprobe -v quiet -hide_banner \
      -analyzeduration 10000000 -probesize 10000000 \
      -show_format -show_streams -of json "$file" 2>/dev/null)

  if [[ -n "$metadata_json" ]]; then
    # The output is tab-separated (@tsv), which is safer for parsing.
    local metadata_line
    metadata_line=$(echo "$metadata_json" | jq -r '
      [
        .format.tags.title // .streams[0]?.tags?.title // .format.tags.TIT2 // .streams[0]?.tags?.TIT2 // .format.tags.NAME // .streams[0]?.tags?.NAME // .format.tags.TITLE // .streams[0]?.tags?.TITLE // .format.tags."Track name" // .streams[0]?.tags?."Track name" // "",
        .format.tags.artist // .streams[0]?.tags?.artist // .format.tags.TPE1 // .streams[0]?.tags?.TPE1 // .format.tags.TPE2 // .streams[0]?.tags?.TPE2 // .format.tags.album_artist // .streams[0]?.tags?.album_artist // .format.tags.ARTIST // .streams[0]?.tags?.ARTIST // .format.tags.Performer // .streams[0]?.tags?.Performer // "",
        .format.tags.album // .streams[0]?.tags?.album // .format.tags.TALB // .streams[0]?.tags?.TALB // .format.tags.ALBUM // .streams[0]?.tags?.ALBUM // "",
        .format.tags.genre // .streams[0]?.tags?.genre // .format.tags.TCON // .streams[0]?.tags?.TCON // .format.tags.GENRE // .streams[0]?.tags?.GENRE // ""
      ] | @tsv
    ')

    # Read the tab-separated output from jq directly into variables.
    IFS=$'\t' read -r title artist album genre <<< "$metadata_line"
  else
      log_debug "ffprobe returned empty JSON for: $file"
  fi

  # --- Attempt 2: Fallback to mediainfo if ffprobe didn't find title/artist ---
  # Only try mediainfo if both title AND artist are still empty from ffprobe
  if [[ -z "$title" && -z "$artist" ]]; then
    if command -v mediainfo &>/dev/null; then
      # Use mediainfo to get specific fields
      local mediainfo_raw
      log_debug "Using mediainfo fallback for '$file' (ffprobe failed to find title/artist)."
      mediainfo_raw=$(mediainfo --Inform="General;%Track_Name%|%Performer%" "$file" 2>/dev/null)

      log_debug "mediainfo raw output for '$file':"
      log_debug "$mediainfo_raw"

      if [[ -n "$mediainfo_raw" ]]; then
        # Split by pipe '|' which is the default separator for --Inform
        IFS='|' read -r title artist <<< "$mediainfo_raw"
        log_debug "MediaInfo found - Title: '$title', Artist: '$artist'"
      fi
    fi
  fi

  # Final cleanup for newlines/carriage returns and potential quotes
  title=$(echo "$title" | tr -d '\n\r' | sed 's/^"//;s/"$//')
  artist=$(echo "$artist" | tr -d '\n\r' | sed 's/^"//;s/"$//')
  album=$(echo "$album" | tr -d '\n\r' | sed 's/^"//;s/"$//')
  genre=$(echo "$genre" | tr -d '\n\r' | sed 's/^"//;s/"$//')

  # --- Apply Default Values ---
  # Fallback to filename for title if still empty
  if [[ -z "$title" ]]; then
    title="$(basename "$file" | sed 's/\.[^.]*$//')" # Get filename without extension
    log_debug "No metadata title found. Using filename: $title"
  fi

  # Default other empty fields to UNKNOWN
  artist="${artist:-UNKNOWN}"
  album="${album:-UNKNOWN}"
  genre="${genre:-UNKNOWN}"

  log_debug "Parsed: Title='${title:0:50}', Artist='${artist:0:50}', Album='${album:0:50}'"

 # Output as tab-separated string to avoid issues with commas in titles
  echo -e "${title}\t${artist}\t${album}\t${genre}"
}
# --- Temporary Index Build Function ---
# Builds a temporary index for a given directory.
legacy_build_temp_index() {
    local custom_dir="$1"
    local -n temp_index_ref=$2
    local ext_filter=("${EXT_FILTER[@]}")

    log_verbose "Temporarily indexing files from '$custom_dir' for selection..."

    create_temp_file temp_index_ref
    create_temp_file temp_json_lines

    # Detect if find supports -printf (Linux/GNU)
    local use_printf=false
    if find /dev/null -printf "" >/dev/null 2>&1; then use_printf=true; fi

    local count=0
    local total_files=0

    # PRE-FLIGHT COUNT: Calculate total files first for progress bar
    if [[ "$use_printf" == true ]]; then
         # Count dots (one per file)
         total_files=$(find "$custom_dir" -type f \( "${ext_filter[@]}" \) -printf '.' | wc -c)
    else
         # Fallback count
         total_files=$(find "$custom_dir" -type f \( "${ext_filter[@]}" \) | wc -l)
    fi

    # --- OPTIMIZATION: FAST PATH (Linux) vs SLOW PATH (Mac/BSD) ---
    if [[ "$use_printf" == true ]]; then
        # Linux: Get path, size, mtime in one pass
        while IFS= read -r -d '' file_path && IFS= read -r -d '' size && IFS= read -r -d '' mtime_full; do
            count=$((count + 1))

            # PROGRESS BAR
            if [[ "$VERBOSE" == true ]]; then
                 local fname=$(basename "$file_path")
                 if [[ ${#fname} -gt 30 ]]; then fname="${fname:0:27}..."; fi
                 printf "\rIndexing: %d/%d (%s)          " "$count" "$total_files" "$fname" >&2
            else
                 printf "\rIndexing: %d/%d          " "$count" "$total_files" >&2
            fi

            local mtime=${mtime_full%%.*}
            local raw_metadata_output
            raw_metadata_output=$(get_audio_metadata "$file_path")
            IFS=$'\t' read -r title artist album genre <<< "$raw_metadata_output"

            local file_ext="${file_path##*.}"
            file_ext="${file_ext,,}"
            local media_type="UNKNOWN"
            if [[ " ${AUDIO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then media_type="audio"
            elif [[ " ${VIDEO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then media_type="video"
            elif [[ " ${PLAYLIST_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then media_type="playlist"; fi

            echo "{\"path\":\"$(json_escape "$file_path")\",\"title\":\"$(json_escape "$title")\",\"artist\":\"$(json_escape "$artist")\",\"album\":\"$(json_escape "$album")\",\"genre\":\"$(json_escape "$genre")\",\"mtime\":\"$mtime\",\"size\":\"$size\",\"media_type\":\"$media_type\"}" >> "$temp_json_lines"

        done < <(find "$custom_dir" -type f \( "${ext_filter[@]}" \) -printf "%p\0%s\0%T@\0")
    else
        # Fallback for systems without -printf
        local all_files=()
        while IFS= read -r -d '' file; do all_files+=("$file"); done < <(find "$custom_dir" -type f \( "${ext_filter[@]}" \) -print0)
        # Total is already known here since we used array
        total_files=${#all_files[@]}

        for file_path in "${all_files[@]}"; do
            count=$((count + 1))

            # PROGRESS BAR RESTORED
            if [[ "$VERBOSE" == true ]]; then
                 local fname=$(basename "$file_path")
                 if [[ ${#fname} -gt 30 ]]; then fname="${fname:0:27}..."; fi
                 printf "\rIndexing: %d/%d (%s)          " "$count" "$total_files" "$fname" >&2
            else
                 printf "\rIndexing: %d/%d          " "$count" "$total_files" >&2
            fi

            local mtime=$(get_mtime "$file_path" || echo "")
            local size=$(get_size "$file_path" || echo "")
            local raw_metadata_output=$(get_audio_metadata "$file_path")
            IFS=$'\t' read -r title artist album genre <<< "$raw_metadata_output"

            local file_ext="${file_path##*.}"
            file_ext="${file_ext,,}"
            local media_type="UNKNOWN"
            if [[ " ${AUDIO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then media_type="audio"
            elif [[ " ${VIDEO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then media_type="video"
            elif [[ " ${PLAYLIST_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then media_type="playlist"; fi

            echo "{\"path\":\"$(json_escape "$file_path")\",\"title\":\"$(json_escape "$title")\",\"artist\":\"$(json_escape "$artist")\",\"album\":\"$(json_escape "$album")\",\"genre\":\"$(json_escape "$genre")\",\"mtime\":\"$mtime\",\"size\":\"$size\",\"media_type\":\"$media_type\"}" >> "$temp_json_lines"
        done
    fi

    echo "" >&2

    if [[ "$count" -eq 0 ]]; then
        msg_warn "No music files found in '$custom_dir'."
        : > "$temp_index_ref"
        rm "$temp_json_lines"
        return 1
    fi

    mv "$temp_json_lines" "$temp_index_ref"
    log_verbose "Temporary index created at '$temp_index_ref'."
}

# Builds or rebuilds the entire music index.
legacy_build_music_index() {
  reload_config_state
  local music_dirs=("${MUSIC_DIRS_ARRAY[@]}")
  local ext_filter=("${EXT_FILTER[@]}")

  log_verbose "Indexing music library for the first time..."

  create_temp_file temp_json_lines

  # Detect if find supports -printf
  local use_printf=false
  if find /dev/null -printf "" >/dev/null 2>&1; then use_printf=true; fi

  # PRE-FLIGHT COUNT: We must count ALL files across ALL dirs first for accurate X/Y
  local total_files=0
  log_verbose "Counting files..."
  for dir_path in "${music_dirs[@]}"; do
      if [[ -d "$dir_path" ]]; then
          local dir_count=0
          if [[ "$use_printf" == true ]]; then
             dir_count=$(find "$dir_path" -type f \( "${ext_filter[@]}" \) -printf '.' | wc -c)
          else
             dir_count=$(find "$dir_path" -type f \( "${ext_filter[@]}" \) | wc -l)
          fi
          total_files=$((total_files + dir_count))
      fi
  done

  local count=0

  # Populate all_music_files
  for dir_path in "${music_dirs[@]}"; do
    if [[ -d "$dir_path" ]]; then

      # --- OPTIMIZED INDEXING LOOP ---
      if [[ "$use_printf" == true ]]; then
          while IFS= read -r -d '' file_path && IFS= read -r -d '' size && IFS= read -r -d '' mtime_full; do
              count=$((count + 1))

              # PROGRESS BAR
              if [[ "$VERBOSE" == true ]]; then
                   local fname=$(basename "$file_path")
                   if [[ ${#fname} -gt 30 ]]; then fname="${fname:0:27}..."; fi
                   printf "\rIndexing: %d/%d (%s)          " "$count" "$total_files" "$fname" >&2
              else
                   printf "\rIndexing: %d/%d          " "$count" "$total_files" >&2
              fi

              local mtime=${mtime_full%%.*}
              local raw_metadata_output="$(get_audio_metadata "$file_path")"
              IFS=$'\t' read -r -a metadata_array <<< "$raw_metadata_output"

              local title="${metadata_array[0]}"
              local artist="${metadata_array[1]}"
              local album="${metadata_array[2]}"
              local genre="${metadata_array[3]}"

              local file_ext="${file_path##*.}"
              file_ext="${file_ext,,}"
              local media_type="UNKNOWN"
              if [[ " ${AUDIO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then media_type="audio"
              elif [[ " ${VIDEO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then media_type="video"
              elif [[ " ${PLAYLIST_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then media_type="playlist"; fi

              echo "{\"path\":\"$(json_escape "$file_path")\",\"title\":\"$(json_escape "$title")\",\"artist\":\"$(json_escape "$artist")\",\"album\":\"$(json_escape "$album")\",\"genre\":\"$(json_escape "$genre")\",\"mtime\":\"$mtime\",\"size\":\"$size\",\"media_type\":\"$media_type\"}" >> "$temp_json_lines"
          done < <(find "$dir_path" -type f \( "${ext_filter[@]}" \) -printf "%p\0%s\0%T@\0")
      else
          # Fallback
          local all_music_files=()
          while IFS= read -r -d '' file; do all_music_files+=("$file"); done < <(find "$dir_path" -type f \( "${ext_filter[@]}" \) -print0)

          for file_path in "${all_music_files[@]}"; do
              count=$((count + 1))

              # PROGRESS BAR
              if [[ "$VERBOSE" == true ]]; then
                   local fname=$(basename "$file_path")
                   if [[ ${#fname} -gt 30 ]]; then fname="${fname:0:27}..."; fi
                   printf "\rIndexing: %d/%d (%s)          " "$count" "$total_files" "$fname" >&2
              else
                   printf "\rIndexing: %d/%d          " "$count" "$total_files" >&2
              fi

              local mtime=$(get_mtime "$file_path" || echo "")
              local size=$(get_size "$file_path" || echo "")
              local raw_metadata_output="$(get_audio_metadata "$file_path")"
              IFS=$'\t' read -r -a metadata_array <<< "$raw_metadata_output"

              local title="${metadata_array[0]}"
              local artist="${metadata_array[1]}"
              local album="${metadata_array[2]}"
              local genre="${metadata_array[3]}"

              local file_ext="${file_path##*.}"
              file_ext="${file_ext,,}"
              local media_type="UNKNOWN"
              if [[ " ${AUDIO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then media_type="audio"
              elif [[ " ${VIDEO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then media_type="video"
              elif [[ " ${PLAYLIST_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then media_type="playlist"; fi

              echo "{\"path\":\"$(json_escape "$file_path")\",\"title\":\"$(json_escape "$title")\",\"artist\":\"$(json_escape "$artist")\",\"album\":\"$(json_escape "$album")\",\"genre\":\"$(json_escape "$genre")\",\"mtime\":\"$mtime\",\"size\":\"$size\",\"media_type\":\"$media_type\"}" >> "$temp_json_lines"
          done
      fi
    else
      msg_warn "Configured music directory '$dir_path' does not exist. Skipping."
    fi
  done

  echo "" >&2
  if [[ "$count" -eq 0 ]]; then
    msg_warn "No music files found in configured directories. Index will be empty."
    : > "$MUSIC_INDEX_FILE"
    rm "$temp_json_lines"
    return 0
  fi

  # --- EFFICIENT JSON ASSEMBLY ---
  # Just move the JSONL file to the final location.
  mv "$temp_json_lines" "$MUSIC_INDEX_FILE"

  log_verbose "Index saved to $MUSIC_INDEX_FILE"

  # --- CLEANUP LEGACY JSON ---
    local legacy_index="${MUSIC_INDEX_FILE%.jsonl}.json"
    if [[ -f "$legacy_index" ]]; then
        rm "$legacy_index"
        log_verbose "Removed legacy index file: $(basename "$legacy_index")"
    fi
}

# --- Music Library Update Function ---
# Updates the music index by checking for new, removed, or modified files.
legacy_update_music_index() {
  reload_config_state
  local music_dirs=("${MUSIC_DIRS_ARRAY[@]}")
  local ext_filter=("${EXT_FILTER[@]}")
  local current_files_on_disk=()
  declare -A old_index_map

  log_verbose "Updating music library index..."

  if [[ -f "$MUSIC_INDEX_FILE" ]]; then
    # Read line-by-line to build the map. Fast and low memory.
    # OPTIMIZATION: Dual-Stream Reader (jq + raw file)
    # Avoids spawning a subshell for every line.
    while IFS= read -r path <&3 && IFS= read -r line <&4; do
        if [[ -n "$path" && "$path" != "null" ]]; then
            old_index_map["$path"]="$line"
        fi
    done 3< <(jq -r .path "$MUSIC_INDEX_FILE") 4< "$MUSIC_INDEX_FILE"
  else
    msg_info "Index file not found. Building index for the first time."
    build_music_index
    return 0
  fi

  for dir_path in "${music_dirs[@]}"; do
    if [[ -d "$dir_path" ]]; then
      while IFS= read -r -d '' file; do
        current_files_on_disk+=("$file")
      done < <(find "$dir_path" -type f \( "${ext_filter[@]}" \) -print0)
    fi
  done

  if [[ ${#current_files_on_disk[@]} -eq 0 ]]; then
    msg_warn "No music files found on disk during update scan. Index will be empty."
    # Clear index, save empty state
    : > "$MUSIC_INDEX_FILE"
    return 0
  fi

  # --- OPTIMIZATION ---
  # Create a temporary file to store the JSON for each track, one object per line.
  create_temp_file new_index_lines

  local count=0
  local total=${#current_files_on_disk[@]}

  local cnt_new=0
  local cnt_mod=0
  local cnt_unchanged=0

  for file_path in "${current_files_on_disk[@]}"; do
    count=$((count + 1))

    # SMART PROGRESS BAR
    if [[ "$VERBOSE" == true ]]; then
         local fname=$(basename "$file_path")
         if [[ ${#fname} -gt 30 ]]; then fname="${fname:0:27}..."; fi
         printf "\rScanning and updating: %d/%d (%s)          " "$count" "$total" "$fname" >&2
    else
         printf "\rScanning and updating: %d/%d          " "$count" "$total" >&2
    fi

    local current_mtime=$(get_mtime "$file_path" || echo "")
    local current_size=$(get_size "$file_path" || echo "")
    local track_json_to_add
    local trimmed_file_path="$file_path"

    if [[ -n "${old_index_map[$trimmed_file_path]+x}" ]]; then
      local old_track_json="${old_index_map[$trimmed_file_path]}"
      local old_mtime=$(echo "$old_track_json" | jq -r '.mtime // ""')
      local old_size=$(echo "$old_track_json" | jq -r '.size // ""')

      if [[ "$current_mtime" == "$old_mtime" && "$current_size" == "$old_size" ]]; then
        track_json_to_add="$old_track_json"
        cnt_unchanged=$((cnt_unchanged + 1))
        log_debug "Unchanged: $(basename "$file_path")"
      else
        log_debug "File modified: $(basename "$file_path") (Old Mtime: $old_mtime, New: $current_mtime)"
        cnt_mod=$((cnt_mod + 1))
        local raw_metadata_output=$(get_audio_metadata "$file_path")
        IFS=$'\t' read -r -a metadata_array <<< "$raw_metadata_output"

        local title="${metadata_array[0]}"
        local artist="${metadata_array[1]}"
        local album="${metadata_array[2]}"
        local genre="${metadata_array[3]}"
        local file_ext="${file_path##*.}"
        file_ext="${file_ext,,}"
        local media_type="UNKNOWN"

        if [[ " ${AUDIO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
          media_type="audio"
        elif [[ " ${VIDEO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
          media_type="video"
        elif [[ " ${PLAYLIST_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
          media_type="playlist"
        fi

        track_json_to_add="{\"path\":\"$(json_escape "$trimmed_file_path")\",\"title\":\"$(json_escape "$title")\",\"artist\":\"$(json_escape "$artist")\",\"album\":\"$(json_escape "$album")\",\"genre\":\"$(json_escape "$genre")\",\"mtime\":\"$current_mtime\",\"size\":\"$current_size\",\"media_type\":\"$media_type\"}"
      fi
    else
      log_verbose "New file detected: $(basename "$file_path")"
      cnt_new=$((cnt_new + 1))
      local raw_metadata_output=$(get_audio_metadata "$file_path")
      IFS=$'\t' read -r -a metadata_array <<< "$raw_metadata_output"

      local title="${metadata_array[0]}"
      local artist="${metadata_array[1]}"
      local album="${metadata_array[2]}"
      local genre="${metadata_array[3]}"
      local file_ext="${file_path##*.}"
      file_ext="${file_ext,,}"
      local media_type="UNKNOWN"

      if [[ " ${AUDIO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
        media_type="audio"
      elif [[ " ${VIDEO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
        media_type="video"
      elif [[ " ${PLAYLIST_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
          media_type="playlist"
      fi

      track_json_to_add="{\"path\":\"$(json_escape "$trimmed_file_path")\",\"title\":\"$(json_escape "$title")\",\"artist\":\"$(json_escape "$artist")\",\"album\":\"$(json_escape "$album")\",\"genre\":\"$(json_escape "$genre")\",\"mtime\":\"$current_mtime\",\"size\":\"$current_size\",\"media_type\":\"$media_type\"}"
    fi

    # Append the resulting JSON object (as a single line) to our temp file.
    if [[ -n "$track_json_to_add" ]]; then
      echo "$track_json_to_add" >> "$new_index_lines"
    fi

  done
  printf "\rScanning and updating complete: %d/%d files processed.\n" "$total" "$total" >&2

  # --- OPTIMIZATION: EFFICIENT JSON ASSEMBLY ---
  mv "$new_index_lines" "$MUSIC_INDEX_FILE"

  # SUMMARY REPORT
  log_verbose "Index refreshed."
  log_verbose "Stats: $total Scanned | $cnt_new New | $cnt_mod Modified | $cnt_unchanged Unchanged"
  log_verbose "Index updated and saved to $MUSIC_INDEX_FILE"

  # --- CLEANUP LEGACY JSON ---
    local legacy_index="${MUSIC_INDEX_FILE%.jsonl}.json"
    if [[ -f "$legacy_index" ]]; then
        rm "$legacy_index"
        log_verbose "Removed legacy index file: $(basename "$legacy_index")"
    fi
}
# --- Music Library Indexing Function ---
try_rust_indexer() {

    if [[ -z "$INDEXER_BIN" || ! -x "$INDEXER_BIN" ]]; then
        return 1
    fi

    log_verbose "Rust Indexer found. Engaging Rust Indexer..."

    # Prepare Arguments
    local args=()
    args+=("--audio-exts" "${AUDIO_EXTS[*]}")
    args+=("--video-exts" "${VIDEO_EXTS[*]}")
    args+=("--playlist-exts" "${PLAYLIST_EXTS[*]}")

    if [[ "$VIDEO_OK" == true ]]; then
        args+=("--video")
    fi

    if [ "$SERIAL_MODE" = true ]; then
            args+=("--serial")
            log_verbose "Serial mode enabled. Indexer will not use parallelism."
    fi

    # Directories must be last
    args+=("${MUSIC_DIRS_ARRAY[@]}")

    # Run into a temp file first (Safe Write)
    local temp_rust_out="${MUSIC_INDEX_FILE}.rust.tmp"

    if "$INDEXER_BIN" "${args[@]}" > "$temp_rust_out"; then
        mv "$temp_rust_out" "$MUSIC_INDEX_FILE"
        log_verbose "Rust Indexing Complete."

        # Cleanup legacy .json if it exists
        local legacy_file="${MUSIC_INDEX_FILE%.jsonl}.json"
        [[ -f "$legacy_file" ]] && rm "$legacy_file"

        return 0
    else
        log_verbose "Rust indexer failed (Exit: $?). Falling back..."
        rm -f "$temp_rust_out"
        return 1
    fi
}

build_temp_index() {
    local custom_dir="$1"
    # We pass the NAME of the variable holding the temp file path (for nameref)
    local output_var_name="$2"

    if [[ -n "$INDEXER_BIN" && -x "$INDEXER_BIN" ]]; then
        log_verbose "Rust Indexer Found! Fast indexing '$custom_dir'..."

        # We need to resolve the output file path from the nameref passed in $2
        # Use a local nameref to get the value, or just create a new temp file if needed.
        # However, the caller expects $2 to be populated with the filename.

        # Create a temp file and assign it to the variable passed as $2
        create_temp_file "$output_var_name"
        local -n out_ref="$output_var_name"

        # Prepare Arguments
        local args=()
        args+=("--audio-exts" "${AUDIO_EXTS[*]}")
        args+=("--video-exts" "${VIDEO_EXTS[*]}")
        args+=("--playlist-exts" "${PLAYLIST_EXTS[*]}")

        if [[ "$VIDEO_OK" == true ]]; then
            args+=("--video")
        fi

        if [ "$SERIAL_MODE" = true ]; then
                args+=("--serial")
                log_verbose "Serial mode enabled. Indexer will not use parallelism."
        fi

        # Target Directory
        args+=("$custom_dir")

        # Execute
        if "$INDEXER_BIN" "${args[@]}" > "$out_ref"; then
            return 0
        fi

        log_verbose "Rust indexer failed. Triggering legacy temp build..."
    fi

    legacy_build_temp_index "$custom_dir" "$output_var_name"
}

build_music_index() {
    reload_config_state

    if try_rust_indexer; then
        return 0
    fi

    log_verbose "Rust indexer not found. Triggering legacy build..."
    # Fallback
    legacy_build_music_index
}

update_music_index() {
    reload_config_state

    if try_rust_indexer; then
        return 0
    fi

    log_verbose "Rust indexer not found. Triggering legacy update..."

    # Fallback
    legacy_update_music_index
}
# --- Helper Functions (Defined before main execution logic) ---

# --- Help Function ---
show_help() {
  cat <<EOF
MPV Music (v$VERSION)

Usage:
  mpv-music
  mpv-music [PATH_OR_URL_OR_DIR] [OPTIONS]
  mpv-music [FILTER_FLAGS] [--play-all]

Options:
  -h, --help          Show this help message and exit
  -v, --version       Show version and exit
  -p, --play-all      Play all tracks matching filters directly, skipping selection.
  -l, --playlist      Go directly to interactive Playlist Mode.
  -g, --genre [val]   Filter by genre. Opens interactive picker if no value is given.
  -a, --artist [val]  Filter by artist. Opens interactive picker if no value is given.
  -b, --album [val]   Filter by album. Opens interactive picker if no value is given.
  -t, --title [val]   Filter by title.
  --config [EDITOR]   Open config file in an editor.
  --log [VIEWER]      Set log level.
  --remove-config     Remove config file.
  --remove-log        Remove log file.
  --video-ok          Include video file formats in scans.
  --update            Update mpv-music to the latest version
  --reindex           Force a complete rebuild of the music index.
  --refresh-index     Update index with file changes (smarter, faster).
  -V, --verbose       Increase verbosity level.
  --debug             Print debug messages and enable system tracing.

Interactive Modes (when run with no arguments):
  1) Directory Mode:    Pick entire folders to play.
  2) Track Mode:        Pick individual song files from your library.
  3) Playlist Mode:     Pick and play saved playlists (.m3u, etc.).
  4) Tag Filter Mode:   Filter by Genre, then Artist, then Album.
  5) Play All Mode:     Instantly play all indexed tracks.
  6) Play URL (Stream)  Stream a URL to MPV using yt-dlp.
  7) Manage Directories Manage music directories to index.

Note: Requires GNU find, fzf, jq, and ffprobe.
EOF
}

# --- Play All Music Function ---
play_all_music() {
    log_verbose "Getting all tracks from the index..."

    # Check if index exists
    if [[ ! -s "$INDEX_TO_USE" ]]; then
        msg_error "Music index is empty or not found. Cannot play all."
        msg_note "Try running --reindex first."
        exit 1
    fi

    msg_success "Streaming all tracks to MPV..."

    jq -r '.path' "$INDEX_TO_USE" | mpv "${MPV_ARGS[@]}" --playlist=-

    exit 0
}

# --- Interactive Filter Helper ---
# Prompts the user to select a value for a given metadata key (e.g., genre, artist).
interactive_filter() {
    local filter_key="$1"
    local fzf_prompt="$2"
    local temp_filter_list
    create_temp_file temp_filter_list

    local icon=""
    case "$filter_key" in
        "genre")  icon="ðŸŽ¶ " ;;
        "artist") icon="ðŸŽ¤ " ;;
        "album")  icon="ðŸ’¿ " ;;
    esac

    # GENERATE LIST
    # Col 1: ID
    # Col 2: Visual Tag (Icon + Name) this is what we see in the list.
    # Col 3: Raw Tag (Name Only)     what we return to the script.
    # Col 4: Count                   hidden from list, shown in preview.
    # Col 5: Samples                 hidden from list, shown in preview.
    jq -rs --arg key "$filter_key" --arg icon "$icon" '
        map(select(.[$key] != null and .[$key] != "" and .[$key] != "Playlist")) |
        map({
            tag: (.[$key] | tostring | gsub("[,/]"; ",") | split(",") | .[] | sub("^\\s+";"") | sub("\\s+$";"")),
            track: .
        }) |
        group_by(.tag) | .[] |
        [
            ($icon + .[0].tag),                           # Field 2: Visual
            .[0].tag,                                     # Field 3: Raw
            length,                                       # Field 4: Count
            ([.[0:5][] | .track.title] | join(" | "))     # Field 5: Samples
        ] | @tsv
    ' "$INDEX_TO_USE" | sort -f | nl -w1 -s$'\t' > "$temp_filter_list"

    # SELECT
    local selected_lines
        selected_lines=$(cat "$temp_filter_list" | \
            fzf --multi \
                --delimiter="\t" \
                --with-nth=2 \
                --prompt="$fzf_prompt" \
                --preview="
                    RAW=\$(sed -n {1}p '$temp_filter_list');
                    IFS=\$'\t' read -r _ visual raw count samples <<< \"\$RAW\";
                    echo -e \"\033[1;36mTag:\033[0m \${raw}\";
                    echo -e \"\033[1;33mTracks:\033[0m \${count}\";
                    echo -e \"\033[1;32mSamples:\033[0m \${samples}\";
                " \
                --preview-window=top:5) || true  # <--- Added || true

        if [[ -z "$selected_lines" ]]; then
            msg_warn "No selection made. Exiting."
            exit 1
        fi

        echo "$selected_lines" | cut -d$'\t' -f3
}

# --- Modes: Functions ---
run_dir_mode() {
    if [[ ! -f "$INDEX_TO_USE" || ! -s "$INDEX_TO_USE" ]]; then
        msg_error "Index file is missing or empty. Cannot proceed."
        exit 1
    fi

    local temp_folder_list
    create_temp_file temp_folder_list

    # OPTIMIZATION: Group tracks by directory.
    # slurp and map() cuz group_by needs an array.
    jq -rs '
        map(select(.path != null)) |
        group_by(.path | split("/")[:-1] | join("/")) | .[] |
        (.[0].path | split("/")[:-1] | join("/")) as $dir_path |
        [
            "ðŸ“ " + ($dir_path | split("/") | .[-1]), # Field 2: Visual (Has Emoji)
            $dir_path,                                # Field 3: Full Path (Clean)
            length,                                   # Field 4: Count
            ([.[0:5][].title] | join(", "))           # Field 5: Samples
        ] | @tsv
    ' "$INDEX_TO_USE" | nl -w1 -s$'\t' > "$temp_folder_list"

    if [[ ! -s "$temp_folder_list" ]]; then
        msg_warn "No playable music folders found in the selection."
        exit 1
    fi

    local SELECTED
    SELECTED=$(cat "$temp_folder_list" | fzf --multi \
        --delimiter="\t" \
        --with-nth=2 \
        --prompt="ðŸ“ Pick folder(s) (TAB to multi-select): " \
        --preview="
            RAW=\$(sed -n {1}p '$temp_folder_list');

            # We read 'visual' but we IGNORE it for the echo.
            # We use 'path' to get the clean name.
            IFS=\$'\t' read -r _ visual path count samples <<< \"\$RAW\";

            # CLEAN NAME: Strip path to just the folder name
            CLEAN_NAME=\"\${path##*/}\";

            echo -e \"\033[1;36mFolder:\033[0m \${CLEAN_NAME}\";
            echo -e \"\033[1;34mPath:\033[0m \${path}\";
            echo -e \"\033[1;33mTracks:\033[0m \${count}\";
            echo -e \"\033[1;32mSample:\033[0m \${samples}\";
        " \
        --preview-window=top:6) || {
        msg_warn "No folders picked."
        exit 1
    }

    [[ -z "$SELECTED" ]] && msg_warn "No folders picked." && exit 1

    # Extract Paths (Column 3)
    mapfile -t FOLDERS < <(echo "$SELECTED" | cut -d$'\t' -f3)
    log_verbose "Selected ${#FOLDERS[@]} folder(s)."

    local FILES=()
    for DIR in "${FOLDERS[@]}"; do
        local TRACK_PATHS
        # Use jq to find files in this dir.
        TRACK_PATHS=$(jq -r --arg dir_prefix "${DIR}/" 'select(.path | startswith($dir_prefix)) | .path' "$INDEX_TO_USE")
        while IFS= read -r TRACK_FILE; do
            [[ -n "$TRACK_FILE" ]] && FILES+=("$TRACK_FILE")
        done <<< "$TRACK_PATHS"
    done

    [[ ${#FILES[@]} -eq 0 ]] && msg_warn "No music found in those folders." && exit 1

    msg_success "Playing ${#FILES[@]} file(s)..."
    mpv "${MPV_ARGS[@]}" "${FILES[@]}"
}

run_track_mode() {
    if [[ ! -f "$INDEX_TO_USE" || ! -s "$INDEX_TO_USE" ]]; then
        msg_error "Index file is missing or empty. Cannot proceed."
        exit 1
    fi

    local temp_track_list
    create_temp_file temp_track_list

    # LINE NUMBERS
    jq -r 'select(.media_type != "playlist") |
      [
          (if .media_type == "video" then "ðŸŽ¬ " else "ðŸŽµ " end) + (.title // "[NO TITLE]"),
          .title // "[NO TITLE]",
          .artist // "[NO ARTIST]",
          .album // "[NO ALBUM]",
          .genre // "[NO GENRE]",
          .media_type // "UNKNOWN",
          .path
      ] | @tsv' "$INDEX_TO_USE" | nl -w1 -s$'\t' > "$temp_track_list"

    local SELECTED
    SELECTED=$(cat "$temp_track_list" | fzf --multi \
      --prompt="ðŸŽµ Pick your tracks (TAB to multi-select): " \
      --delimiter="\t" \
      --with-nth=2 \
      --preview="
          RAW=\$(sed -n {1}p '$temp_track_list');
          IFS=\$'\t' read -r _ visual title artist album genre type path <<< \"\$RAW\";
          echo -e \"\033[1;36mTitle:\033[0m \${title}\";
          echo -e \"\033[1;33mArtist:\033[0m \${artist}\";
          echo -e \"\033[1;32mAlbum:\033[0m \${album}\";
          echo -e \"\033[1;35mGenre:\033[0m \${genre}\";
          echo -e \"\033[1;34mPath:\033[0m \${path}\";
      " \
      --preview-window=top:6 | awk -F'\t' '{print $NF}') || true

    if [[ -z "$SELECTED" ]]; then
        msg_warn "No tracks picked."
        exit 1
    fi

    mapfile -t FILES <<< "$SELECTED"

    msg_success "Playing ${#FILES[@]} track(s)..."
    mpv "${MPV_ARGS[@]}" "${FILES[@]}"
}

run_playlist_mode() {
    local temp_playlist_list
    create_temp_file temp_playlist_list

    jq -r 'select(.media_type == "playlist") |
      [
          "ðŸ“œ " + (.title // (.path | split("/") | .[-1])),
          .path
      ] | @tsv' "$INDEX_TO_USE" | nl -w1 -s$'\t' > "$temp_playlist_list"

    if [[ ! -s "$temp_playlist_list" ]]; then
        msg_warn "No playlists found in the index."
        return
    fi

    local SELECTED
    SELECTED=$(cat "$temp_playlist_list" | fzf --multi \
        --delimiter="\t" \
        --with-nth=2 \
        --prompt="ðŸ“œ Select playlist(s) (TAB to multi-select): " \
        --preview="
            RAW=\$(sed -n {1}p '$temp_playlist_list');
            IFS=\$'\t' read -r _ title path <<< \"\$RAW\";

            # REMOVE EMOJI: Strip everything up to the first space
            CLEAN_TITLE=\"\${title#* }\";

            echo -e \"\033[1;34mPlaylist:\033[0m \${CLEAN_TITLE}\";
            if [[ -f \"\$path\" ]]; then
                echo -e \"\033[1;33mContents (Top 10):\033[0m\";
                head -n 10 \"\$path\";
            else
                echo -e \"\033[1;31mError: File not found.\033[0m\";
            fi
        " \
        --preview-window=top:10 | cut -d$'\t' -f3) || true

    [[ -z "$SELECTED" ]] && msg_warn "No playlist picked." && return

    mapfile -t PLAYLISTS <<< "$SELECTED"
    mpv "${MPV_ARGS[@]}" "${PLAYLISTS[@]}"
}

run_tag_mode() {
    echo -e "${CYAN}ðŸ”Ž Filter by:${NC}"
    echo "1) Genre"
    echo "2) Artist"
    echo "3) Album"
    read -rp "Enter choice [1/2/3]: " FILTER_CHOICE

    filter_key=""
    fzf_prompt=""

    case "$FILTER_CHOICE" in
        1) filter_key="genre"; fzf_prompt="ðŸŽ¶ Pick genre(s) (TAB to select multiple): ";;
        2) filter_key="artist"; fzf_prompt="ðŸŽ¤ Pick artist(s) (TAB to select multiple): ";;
        3) filter_key="album"; fzf_prompt="ðŸ’¿ Pick album(s) (TAB to select multiple): ";;
        *) msg_error "Invalid choice. Exiting."; exit 1;;
    esac

    # Get one or more selections from the user
    selected_filter_values_str=$(interactive_filter "$filter_key" "$fzf_prompt")
    mapfile -t selected_values_array <<< "$selected_filter_values_str"

    # Create a JSON array
    jq_values_array=$(printf '%s\n' "${selected_values_array[@]}" | jq -R . | jq -s .)

    log_verbose "Filtering by $filter_key: ${selected_values_array[*]}..."

    # Create a temporary index with tracks matching ANY of the selected values
    create_temp_file filtered_index_file

# stream filter to a temporary JSONL file.
    # LOGIC:
    # 1. Turn "Rock, Pop" into ["Rock", "Pop"]
    # 2. Check if the User's Selection is EXACTLY inside that list.
    jq -c --arg key "$filter_key" --argjson values "$jq_values_array" '
        select(
            # 1. CLEAN & SPLIT the track tags
            (.[$key] // "" | tostring | gsub("[,/]"; ",") | split(",") | map(sub("^\\s+";"") | sub("\\s+$";""))) as $track_tags |

            # 2. EXACT MATCH CHECK
            # We check if ANY of the user selections ($values) exist strictly inside $track_tags
            # index($v) returns a number (found) or null (not found).
            # In jq, numbers are truthy, null is falsy.
            $values | any( . as $v | ($track_tags | index($v)) )
        )
    ' "$INDEX_TO_USE" > "$filtered_index_file"

    # wc -l because it is a file of lines, not a JSON array
    track_count=$(wc -l < "$filtered_index_file")

    if [[ "$track_count" -eq 0 ]]; then
        msg_warn "No tracks found matching that filter."
        exit 1
    fi

    msg_success "Found $track_count matching track(s)."
    echo "What's next?"
    echo "1) Play all $track_count tracks"
    echo "2) Select individual tracks"
    read -rp "Enter choice [1/2]: " PLAY_CHOICE

    case "$PLAY_CHOICE" in
        1) # Play All
            mapfile -t FILES < <(jq -r '.path' "$filtered_index_file")
            msg_success "Playing all..."
            mpv "${MPV_ARGS[@]}" "${FILES[@]}"
            ;;
        2) # Select Individual
            create_temp_file temp_track_list

            # line number here too
            jq -r '
                  [
                      (if .media_type == "video" then "ðŸŽ¬ " else "ðŸŽµ " end) + (.title // "[NO TITLE]"),
                      .title // "[NO TITLE]",
                      .artist // "[NO ARTIST]",
                      .album // "[NO ALBUM]",
                      .genre // "[NO GENRE]",
                      .media_type // "UNKNOWN",
                      .path
                  ] | @tsv' "$filtered_index_file" | nl -w1 -s$'\t' > "$temp_track_list"

            # safe preview
            SELECTED=$(cat "$temp_track_list" | fzf --multi \
              --prompt="ðŸŽµ Pick your filtered tracks (TAB to multi-select): " \
              --delimiter="\t" \
              --with-nth=2 \
              --preview="
                  RAW=\$(sed -n {1}p '$temp_track_list');
                  IFS=\$'\t' read -r _ display title artist album genre type path <<< \"\$RAW\";
                  echo -e \"\033[1;36mTitle:\033[0m \${title}\";
                  echo -e \"\033[1;33mArtist:\033[0m \${artist}\";
                  echo -e \"\033[1;32mAlbum:\033[0m \${album}\";
                  echo -e \"\033[1;35mGenre:\033[0m \${genre}\";
                  echo -e \"\033[1;34mType:\033[0m \${type}\";
              " \
              --preview-window=top:6 | awk -F'\t' '{print $NF}')

            [[ -z "$SELECTED" ]] && msg_warn "No tracks picked." && exit 1
            mapfile -t FILES <<< "$SELECTED"

            msg_success "Playing ${#FILES[@]} track(s)..."
            mpv "${MPV_ARGS[@]}" "${FILES[@]}"
            ;;
        *)
            msg_warn "Invalid choice. Exiting."
            exit 1
            ;;
    esac
}

run_play_all_mode() {
    play_all_music
}

# --- Management Mode ---
run_manage_dirs_mode() {
    while true; do
        echo -e "\n${CYAN}ðŸ“‚ Managed Directories:${NC}"

        # FREEEEESH DATA (Populates MUSIC_DIRS_ARRAY)
        reload_config_state

        if [[ ${#MUSIC_DIRS_ARRAY[@]} -eq 0 ]]; then
             msg_warn "No directories configured"
        else
             local i=1
             for d in "${MUSIC_DIRS_ARRAY[@]}"; do
                 echo "   $i) $d"
                 ((i++))
             done
        fi

        echo ""
        echo "   [A] Add Directory"
        echo "   [R] Remove Directory"
        echo "   [q] Quit"

        read -rp "Action: " ACTION

        case "${ACTION,,}" in
            a|add)
                read -rp "Enter path to add: " NEW_PATH
                # Tilde expansion hack
                NEW_PATH="${NEW_PATH/#\~/$HOME}"
                if [[ -n "$NEW_PATH" ]]; then
                    config_add_dir "$NEW_PATH"
                fi
                ;;
            r|remove)
                if [[ ${#MUSIC_DIRS_ARRAY[@]} -eq 0 ]]; then
                    msg_warn "Nothing to remove."
                    continue
                fi

                read -rp "Enter NUMBER to remove: " IDX

                # Validate input is a number
                if [[ "$IDX" =~ ^[0-9]+$ ]]; then
                    # Adjust for 0-based array
                    local array_idx=$((IDX-1))

                    # Check bounds against MUSIC_DIRS_ARRAY length
                    if [[ "$array_idx" -ge 0 && "$array_idx" -lt "${#MUSIC_DIRS_ARRAY[@]}" ]]; then
                        local path_to_remove="${MUSIC_DIRS_ARRAY[$array_idx]}"
                        config_remove_dir "$path_to_remove"
                    else
                        msg_error "Invalid number ($IDX). Please pick 1-${#MUSIC_DIRS_ARRAY[@]}."
                    fi
                else
                    msg_error "Please enter a valid number."
                fi
                ;;
            q|quit)
                return
                ;;
            *)
                msg_warn "Invalid option. Press 'r' then the number."
                ;;
        esac
    done
}
# --- Global Variables (Initial values) ---
CUSTOM_EXTS=""
MPV_ARGS=()
DIRECT_PLAY_TARGET="" # Will store the file path or URL if provided
CUSTOM_MUSIC_DIR="" # Will store a custom music directory if provided
declare -a GENRE_FILTERS=()
declare -a ARTIST_FILTERS=()
declare -a ALBUM_FILTERS=()
declare -a TITLE_FILTERS=()
CLI_FILTER_ACTIVE=false
PLAY_ALL=false
CLI_PLAYLIST_MODE=false

# Deferred interactive filter flags
GENRE_INTERACTIVE=false
ARTIST_INTERACTIVE=false
ALBUM_INTERACTIVE=false
TITLE_INTERACTIVE=false

# --- Helper Function: Handle Direct Play ---
handle_direct_play() {
  local target="$1"
  local has_url=false
  local has_youtube=false
  local ytdl_opts=""

  # Scan primary target
  if [[ "$target" =~ ^https?://|^ftp://|^yt-dlp:// ]]; then
      has_url=true
      if [[ "$target" =~ (youtube\.com|youtu\.be) ]]; then has_youtube=true; fi
      # Force playlist if 'list=' is present
      # "yes-playlist=" is required by mpv for boolean flags
      if [[ "$target" == *"list="* ]]; then ytdl_opts+="yes-playlist=,"; fi
  fi

  # Scan other args in case user passed multiple URLs
  for arg in "${MPV_ARGS[@]}"; do
      if [[ "$arg" =~ ^https?://|^ftp://|^yt-dlp:// ]]; then
          has_url=true
          if [[ "$arg" =~ (youtube\.com|youtu\.be) ]]; then has_youtube=true; fi
          if [[ "$arg" == *"list="* ]]; then ytdl_opts+="yes-playlist=,"; fi
      fi
  done

  if [[ "$has_url" == true ]]; then
      msg_info "Resolving stream..."
      MPV_ARGS+=("--msg-level=ytdl_hook=info")
  else
      log_verbose "Playing local file: $target"
  fi

  # --- YouTube JS Runtime Auto-Config ---
  # yt-dlp now mandates a JS runtime for YouTube.
  if [[ "$has_youtube" == true ]]; then
      if [[ "$VIDEO_OK" == false ]]; then
          MPV_ARGS+=("--ytdl-format=bestaudio/best")
      fi

      log_verbose "YouTube URL detected."

      if [[ "$YTDLP_EJS_REMOTE_GITHUB" == "true" ]]; then
            log_verbose "Enabling remote EJS component (source: GitHub)..."
            ytdl_opts+="remote-components=ejs:github,"
        fi

      log_verbose "Checking for JS runtimes..."

      if command -v deno &>/dev/null; then
         log_verbose "Deno found (yt-dlp default)."

      elif command -v node &>/dev/null; then
         log_verbose "Using Node.js fallback."
         ytdl_opts+="js-runtimes=node,"

      elif command -v qjs &>/dev/null || command -v quickjs &>/dev/null; then
         log_verbose "Using QuickJS fallback."
         ytdl_opts+="js-runtimes=quickjs,"

      elif command -v bun &>/dev/null; then
         log_verbose "Using Bun fallback."
         ytdl_opts+="js-runtimes=bun,"

      else
         echo ""
         msg_warn "No supported JS runtime found (Deno, Node, QuickJS, Bun)!"
         msg_warn "YouTube playback requires a JS runtime to bypass new anti-bot protections."
         msg_warn "Playback will likely fail with HTTP 403 Forbidden."
         msg_note "Please install 'deno' (recommended) or 'nodejs'."
         echo ""
      fi
  fi

  # Apply accumulated ytdl options (JS runtime + Playlist fix)
  if [[ -n "$ytdl_opts" ]]; then
      log_verbose "Applying yt-dlp options: ${ytdl_opts%,}"
      # Remove trailing comma
      MPV_ARGS+=("--ytdl-raw-options=${ytdl_opts%,}")
  fi

  log_verbose "Executing MPV with target: $target"
  log_debug "MPV Args: ${MPV_ARGS[*]}"

  mpv "${MPV_ARGS[@]}" "$target"

  local mpv_exit_code=$?

    # CRASH HANDLER
    if [[ $mpv_exit_code -ne 0 && "$has_url" == true ]]; then
        echo ""
        msg_warn "MPV exited with error (Code: $mpv_exit_code)."
        msg_info "Checking if yt-dlp is outdated..."

        # Capture output of update check (redirect stderr to stdout)
        # We ignore the exit code of yt-dlp -U because it returns 1 on package-managed systems
        local update_output
        update_output=$(yt-dlp -U 2>&1)

        if [[ "$update_output" == *"Latest version:"* ]]; then
            echo ""
            msg_warn "YOUR YT-DLP IS OUTDATED!"

            local curr_ver=$(echo "$update_output" | grep "Current version" | head -n1)
            local new_ver=$(echo "$update_output" | grep "Latest version" | head -n1)

            echo -e "  ${curr_ver}"
            echo -e "  ${new_ver}"
            echo ""
            msg_note "YouTube constantly breaks older versions."
            msg_note "Please update yt-dlp using your package manager (dnf, apt, pacman) or pip."
            echo ""
        elif [[ "$update_output" == *"up to date"* ]]; then
             log_verbose "yt-dlp is up to date."
        else
             # Fallback if output format is weird
             log_debug "yt-dlp update check output: $update_output"
        fi

        if [[ "$has_youtube" == true && "$YTDLP_EJS_REMOTE_GITHUB" == "false" ]]; then
            echo ""
            msg_note "   If you installed yt-dlp via a package manager (apt/dnf/pacman)"
            msg_note "   instead of the official GitHub binary, it might be missing components."
            msg_note "   Try enabling the remote fix in your config:"
            msg_note "   YTDLP_EJS_REMOTE_GITHUB=true"
            echo ""
        fi
    fi

  exit $mpv_exit_code
}

# --- Early Argument Handling ---
for arg in "$@"; do
  case "$arg" in
    -h|--help)
      show_help
      exit 0
      ;;
  esac
done

# --- Music Library Indexing Check ---
# Build EXT_FILTER here as it's needed by both build_music_index and update_music_index.
# Moved EXT_FILTER building here to ensure it's always available before indexing calls.
build_ext_filter
# EXT_FILTER is now always built here.

# This prevents double-indexing when the file is missing AND --reindex is passed.
SKIP_AUTO_INDEX=false
for arg in "$@"; do
    if [[ "$arg" == "--reindex" || "$arg" == "--refresh-index" ]]; then
        SKIP_AUTO_INDEX=true
        break
    fi
done

INDEX_TO_USE="$MUSIC_INDEX_FILE" # Default to the main index

# --- Argument Parsing ---
# Iterate through all arguments to identify direct play target, script options, or mpv flags
while [[ $# -gt 0 ]]; do
  case "$1" in
    --video-ok) VIDEO_OK=true; shift;;
    --ext=*) CUSTOM_EXTS="${1#--ext=}"; shift;;
    --serial) SERIAL_MODE=true; shift;;
    --refresh-index) ensure_index_integrity; build_ext_filter; update_music_index; exit 0;;
    --reindex) build_ext_filter; log_verbose "Forcing a complete rebuild of the music index."; build_music_index; exit 0;;
    --shuffle) SHUFFLE=true; shift ;;
    --no-shuffle) SHUFFLE=false; shift ;;
    --loop|--loop-playlist) LOOP_MODE="playlist"; shift;;
    --repeat|--loop-track|--loop-file) LOOP_MODE="track"; shift;;
    --no-loop) LOOP_MODE="no"; shift;;
    --vol=*|--volume=*) VOLUME="${1#*=}"; shift;;
    --vol|--volume)
        if [[ -n "${2:-}" && "$2" != -* ]]; then
            VOLUME="$2"
            shift 2
        else
            msg_error "Missing value for --volume."
            exit 1
        fi
        ;;
    --add-dir)
        # Check if we have at least one valid argument
        if [[ -z "${2:-}" || "${2:-}" == -* ]]; then
            msg_error "Missing argument for --add-dir."
            exit 1
        fi

        # Loop to consume all subsequent arguments until a flag is found
        shift # Skip the --add-dir flag itself
        while [[ $# -gt 0 && "$1" != -* ]]; do
            TARGET="${1/#\~/$HOME}"
            config_add_dir "$TARGET" "true"
            changes_made=true
            shift
        done
        if [[ "$changes_made" == true ]]; then
            log_verbose "Applying batch changes..."
            update_music_index
        fi
        exit 0
        ;;

    --remove-dir)
        if [[ -z "${2:-}" || "${2:-}" == -* ]]; then
            msg_error "Missing argument for --remove-dir."
            exit 1
        fi

        shift
        while [[ $# -gt 0 && "$1" != -* ]]; do
            TARGET="${1/#\~/$HOME}"
            config_remove_dir "$TARGET" "true"
            changes_made=true
            shift
        done
        if [[ "$changes_made" == true ]]; then
            log_verbose "Applying batch changes..."
            update_music_index
        fi
        exit 0
        ;;

    --manage-dirs)
        run_manage_dirs_mode
        exit 0
        ;;
    -p|--play-all) PLAY_ALL=true; shift;;
    -l|--playlist) CLI_PLAYLIST_MODE=true; shift;;

    # --- INTELLIGENT FILTER PARSING (deferred interactive) ---
    -g|--genre|-g=*|--genre=*)
        value=""
        if [[ "$1" == *=* ]]; then value="${1#*=}";
        elif [[ -n "${2:-}" && "$2" != -* ]]; then value="$2"; shift; fi

        if [[ -n "$value" ]]; then
            mapfile -t GENRE_FILTERS < <(echo "$value" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep -v '^$')
        else
            GENRE_INTERACTIVE=true
        fi
        CLI_FILTER_ACTIVE=true; shift;;

    -a|--artist|-a=*|--artist=*)
        value=""
        if [[ "$1" == *=* ]]; then value="${1#*=}";
        elif [[ -n "${2:-}" && "$2" != -* ]]; then value="$2"; shift; fi

        if [[ -n "$value" ]]; then
            mapfile -t ARTIST_FILTERS < <(echo "$value" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep -v '^$')
        else
            ARTIST_INTERACTIVE=true
        fi
        CLI_FILTER_ACTIVE=true; shift;;

    -b|--album|-b=*|--album=*)
        value=""
        if [[ "$1" == *=* ]]; then value="${1#*=}";
        elif [[ -n "${2:-}" && "$2" != -* ]]; then value="$2"; shift; fi

        if [[ -n "$value" ]]; then
            mapfile -t ALBUM_FILTERS < <(echo "$value" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep -v '^$')
        else
            ALBUM_INTERACTIVE=true
        fi
        CLI_FILTER_ACTIVE=true; shift;;

    -t|--title|-t=*|--title=*)
        value=""
        if [[ "$1" == *=* ]]; then value="${1#*=}";
        elif [[ -n "${2:-}" && "$2" != -* ]]; then value="$2"; shift; fi

        if [[ -n "$value" ]]; then
            mapfile -t TITLE_FILTERS < <(echo "$value" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep -v '^$')
        else
            TITLE_INTERACTIVE=true
        fi
        CLI_FILTER_ACTIVE=true; shift;;

    *)
      if [[ -z "$DIRECT_PLAY_TARGET" && -z "$CUSTOM_MUSIC_DIR" ]]; then
        if [[ "$1" =~ ^https?://|^ftp://|^file://|^yt-dlp:// ]]; then DIRECT_PLAY_TARGET="$1"; shift; continue;
        elif [[ -f "$1" ]]; then DIRECT_PLAY_TARGET="$1"; shift; continue;
        elif [[ -d "$1" ]]; then CUSTOM_MUSIC_DIR="$1"; shift; continue;
        fi
      fi
      MPV_ARGS+=("$1"); shift;;
  esac
done

rotate_log
ensure_index_integrity

# Logic for handling custom directory vs. default index

if [[ -n "$CUSTOM_MUSIC_DIR" ]]; then
    if ! build_temp_index "$CUSTOM_MUSIC_DIR" temp_index_file; then
        exit 1
    fi
    INDEX_TO_USE="$temp_index_file"
elif [[ "$SKIP_AUTO_INDEX" == false ]]; then
    # Only auto-build if we aren't about to do it manually in the arg parser
    if [[ ! -f "$MUSIC_INDEX_FILE" ]]; then
        msg_info "Index file '$MUSIC_INDEX_FILE' not found. Building index from scratch."
        build_music_index
    fi
fi

# --- Run deferred interactive filters (now INDEX_TO_USE is correct) ---
if [[ "$GENRE_INTERACTIVE" == true ]]; then
    selected_values=$(interactive_filter "genre" "ðŸŽ¶ Pick genre(s): ")
    mapfile -t GENRE_FILTERS <<< "$selected_values"
fi
if [[ "$ARTIST_INTERACTIVE" == true ]]; then
    selected_values=$(interactive_filter "artist" "ðŸŽ¤ Pick artist(s): ")
    mapfile -t ARTIST_FILTERS <<< "$selected_values"
fi
if [[ "$ALBUM_INTERACTIVE" == true ]]; then
    selected_values=$(interactive_filter "album" "ðŸ’¿ Pick album(s): ")
    mapfile -t ALBUM_FILTERS <<< "$selected_values"
fi
if [[ "$TITLE_INTERACTIVE" == true ]]; then
    run_track_mode
    exit 0
fi

# MERGE
final_args=()
for arg in "${MPV_DEFAULT_ARGS_ARRAY[@]}"; do
    if [[ "$arg" == "--shuffle" ]] || [[ "$arg" == "--loop-playlist"* ]] || [[ "$arg" == "--loop-file"* ]]; then
        continue
    fi
    final_args+=("$arg")
done

if [[ "$SHUFFLE" == "true" ]]; then
    final_args+=("--shuffle")
fi

case "$LOOP_MODE" in
    playlist|inf) final_args+=("--loop-playlist=inf") ;;
    track|file)   final_args+=("--loop-file=inf") ;;
    no|off|false) final_args+=("--loop-playlist=no" "--loop-file=no") ;;
    *)
        # Numeric support (e.g. LOOP_MODE="5")
        if [[ "$LOOP_MODE" =~ ^[0-9]+$ ]]; then
             final_args+=("--loop-playlist=$LOOP_MODE")
        fi
        ;;
esac

final_args+=("--volume=$VOLUME")

# Append Raw User Flags (The Override)
# MPV_ARGS contains everything that fell into the *) wildcard loop
final_args+=("${MPV_ARGS[@]}")

MPV_ARGS=("${final_args[@]}")

if [[ -n "$DIRECT_PLAY_TARGET" ]]; then
  handle_direct_play "$DIRECT_PLAY_TARGET"
fi

# --- Handle --play-all without other filters ---
if [[ "$PLAY_ALL" == true && "$CLI_FILTER_ACTIVE" == false && "$CLI_PLAYLIST_MODE" == false ]]; then
    play_all_music
fi

# --- Handle --playlist flag ---
if [[ "$CLI_PLAYLIST_MODE" == true ]]; then
    run_playlist_mode
    exit 0
fi

# --- Handle CLI Filtering if active ---
if [[ "$CLI_FILTER_ACTIVE" == true ]]; then

    # apply_cli_filter now works on FILES, not strings.
    # it reads $file_to_filter, applies jq logic, and overwrites the file with results.
    apply_cli_filter() {
        local file_to_filter="$1"
        local mode="$2"
        local key="$3"
        shift 3
        local -a values=("$@")
        local -a escaped_values=()

        # Escape special regex characters: . ^ $ * + ? ( ) [ ] { } | \
        for val in "${values[@]}"; do
            escaped_values+=("$(echo "$val" | sed 's/\\/\\\\/g; s/[][(){}^$*+?.|]/\\&/g')")
        done

        local jq_values_array
        jq_values_array=$(printf '%s\n' "${escaped_values[@]}" | jq -R . | jq -s .)

        local jq_filter
        if [[ "$mode" == "exact" ]]; then
            # Case-insensitive WHOLE WORD match
            jq_filter='($values | join("|")) as $regex | select(.[$key] | test("\\b(" + $regex + ")\\b"; "i"))'
        else # "contains"
            # Case-insensitive CONTAINS match
            jq_filter='($values | join("|")) as $regex | select(.[$key] | test($regex; "i"))'
        fi

        log_debug "Applying Filter ($mode) on '$key'"
        log_debug "Values: ${values[*]}"
        log_debug "JQ Query: $jq_filter"

        local temp_out
        create_temp_file temp_out

        # Apply filter stream -> temp
        jq -c --arg key "$key" --argjson values "$jq_values_array" \
            "$jq_filter" "$file_to_filter" > "$temp_out"

        # Move back to original file path (update in place)
        mv "$temp_out" "$file_to_filter"
    }

    # --- Stage 1: Attempt an Exact (Whole Word) Match ---
    log_verbose "Trying smart match..."

    # Create a working copy of the index so we don't destroy the original
    create_temp_file working_subset
    cp "$INDEX_TO_USE" "$working_subset"

    if [[ ${#GENRE_FILTERS[@]} -gt 0 ]]; then apply_cli_filter "$working_subset" "exact" "genre" "${GENRE_FILTERS[@]}"; fi
    if [[ ${#ARTIST_FILTERS[@]} -gt 0 ]]; then apply_cli_filter "$working_subset" "exact" "artist" "${ARTIST_FILTERS[@]}"; fi
    if [[ ${#ALBUM_FILTERS[@]} -gt 0 ]]; then apply_cli_filter "$working_subset" "exact" "album" "${ALBUM_FILTERS[@]}"; fi
    if [[ ${#TITLE_FILTERS[@]} -gt 0 ]]; then apply_cli_filter "$working_subset" "exact" "title" "${TITLE_FILTERS[@]}"; fi

    # wc -l for counting lines
    track_count=$(wc -l < "$working_subset")

    if [[ "$track_count" -eq 0 ]]; then
        log_verbose "No smart match found. Searching for partial matches..."

        # Reset working set to full index
        cp "$INDEX_TO_USE" "$working_subset"

        active_filter_key=""
        active_filter_values=()

        if [[ ${#ARTIST_FILTERS[@]} -gt 0 ]]; then
            active_filter_key="artist"; active_filter_values=("${ARTIST_FILTERS[@]}")
        elif [[ ${#GENRE_FILTERS[@]} -gt 0 ]]; then
            active_filter_key="genre"; active_filter_values=("${GENRE_FILTERS[@]}")
        elif [[ ${#ALBUM_FILTERS[@]} -gt 0 ]]; then
            active_filter_key="album"; active_filter_values=("${ALBUM_FILTERS[@]}")
        elif [[ ${#TITLE_FILTERS[@]} -gt 0 ]]; then
            active_filter_key="title"; active_filter_values=("${TITLE_FILTERS[@]}")
        fi

        if [[ -n "$active_filter_key" ]]; then
            # Apply "contains" filter to the working subset
            apply_cli_filter "$working_subset" "contains" "$active_filter_key" "${active_filter_values[@]}"

            # Check for ambiguity by looking at the filtered results
            mapfile -t clarification_options < <(jq -r --arg key "$active_filter_key" '.[$key]' "$working_subset" | sort -fu)

            if [[ ${#clarification_options[@]} -eq 1 ]]; then
                log_verbose "Found one likely match: '${clarification_options[0]}'"
                # We already filtered by "contains", but let's be strict if needed.
                # the "contains" result is already in working_subset.
                cp "$INDEX_TO_USE" "$working_subset"
                apply_cli_filter "$working_subset" "exact" "$active_filter_key" "${clarification_options[0]}"

            elif [[ ${#clarification_options[@]} -gt 1 ]]; then
                clarified_str=$(printf '%s\n' "${clarification_options[@]}" | fzf --multi --prompt="Which ${active_filter_key} did you mean? ")
                [[ -z "$clarified_str" ]] && msg_warn "No selection made." && exit 1
                mapfile -t clarified_values <<< "$clarified_str"

                # Reset and re-apply exact on specific value
                cp "$INDEX_TO_USE" "$working_subset"
                apply_cli_filter "$working_subset" "exact" "$active_filter_key" "${clarified_values[@]}"
            fi
        fi
    fi

    # --- Stage 3: Play Results or Ask for Next Action ---
    track_count=$(wc -l < "$working_subset")

    if [[ "$track_count" -eq 0 ]]; then
        msg_error "No matching tracks found."
        exit 1
    fi

    msg_success "Found $track_count matching track(s)."

    if [[ "$PLAY_ALL" == true || "$track_count" -eq 1 ]]; then
        # If --play-all is used OR if there's only one result, play directly
        msg_success "Playing $track_count track(s)..."
        jq -r '.path' "$working_subset" | mpv "${MPV_ARGS[@]}" --playlist=-
    else
        # Otherwise, ask the user what to do
        echo "What's next?"
        echo "1) Play all $track_count tracks"
        echo "2) Select individual tracks from this list"
        read -rp "Enter choice [1/2]: " PLAY_CHOICE </dev/tty

        case "$PLAY_CHOICE" in
            1)
                msg_success "Streaming all tracks to MPV..."
                jq -r '.path' "$working_subset" | mpv "${MPV_ARGS[@]}" --playlist=-
                ;;
            2)
                create_temp_file temp_track_list

                # we add line no for security
                jq -r '
                        [
                            (if .media_type == "video" then "ðŸŽ¬ " else "ðŸŽµ " end) + (.title // "[NO TITLE]"),
                            .title // "[NO TITLE]",
                            .artist // "[NO ARTIST]",
                            .album // "[NO ALBUM]",
                            .genre // "[NO GENRE]",
                            .media_type // "UNKNOWN",
                            .path
                        ] | @tsv' "$working_subset" | nl -w1 -s$'\t' > "$temp_track_list"

                SELECTED=$(cat "$temp_track_list" | fzf --multi \
                    --prompt="ðŸŽµ Pick filtered tracks: " \
                    --delimiter="\t" \
                    --with-nth=2 \
                    --preview="
                        RAW=\$(sed -n {1}p '$temp_track_list');
                        # Capture visual col in dummy var so others align correctly
                        IFS=\$'\t' read -r _ visual title artist album genre type path <<< \"\$RAW\";
                        echo -e \"\033[1;36mTitle:\033[0m \${title}\";
                        echo -e \"\033[1;33mArtist:\033[0m \${artist}\";
                        echo -e \"\033[1;32mAlbum:\033[0m \${album}\";
                        echo -e \"\033[1;35mGenre:\033[0m \${genre}\";
                        echo -e \"\033[1;34mPath:\033[0m \${path}\";
                    " \
                    --preview-window=top:6 | awk -F'\t' '{print $NF}') || true

                if [[ -z "$SELECTED" ]]; then
                    msg_warn "No tracks picked."
                    exit 1
                fi

                mapfile -t FILES <<< "$SELECTED"

                log_verbose "ðŸŽ¶ Selected ${#FILES[@]} track(s)."
                mpv "${MPV_ARGS[@]}" "${FILES[@]}"
                ;;
            *) msg_error "Invalid choice. Exiting."; exit 1;;
            esac
        fi
        exit 0
    fi

# --- Interactive Mode Selection ---
while true; do

    echo -e "${CYAN}ðŸŽ§ Pick mode:${NC}"
    echo "1) Play entire Directory(s)"
    echo "2) Pick individual tracks"
    echo "3) Play a saved playlist"
    echo "4) Filter by Tag..."
    echo "5) Play All Music"
    echo "6) Play URL (Stream)"
    echo "7) Manage Directories"
    echo "q) Quit"

    # Read with prompt. Supports ESC+Enter to quit.
    read -rp "Enter choice [1-7/q]: " MODE || exit 0

    case "$MODE" in
        1) run_dir_mode; exit 0 ;;
        2) run_track_mode; exit 0 ;;
        3) run_playlist_mode; exit 0 ;;
        4) run_tag_mode; exit 0 ;;
        5) run_play_all_mode; exit 0 ;;
        6)
            echo ""
            echo "Paste URL(s) (separated by space):"
            read -rp "> " -a USER_URLS
            if [[ ${#USER_URLS[@]} -gt 0 ]]; then
                TARGET="${USER_URLS[0]}"
                [[ ${#USER_URLS[@]} -gt 1 ]] && MPV_ARGS+=("${USER_URLS[@]:1}")
                handle_direct_play "$TARGET"
            else
                msg_error "No URL provided."
            fi
            exit 0
            ;;
        q|Q|$'\e')
            echo "Bye Bye!"
            exit 0
            ;;
        7) run_manage_dirs_mode; exit 0;;
        *)
            msg_warn "Invalid input. Please pick 1-6 or q."
            sleep 0.5
            echo ""
            ;;
    esac
done
