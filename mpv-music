#!/usr/bin/env bash
# Purpose: MPV wrapper for music playback
set -euo pipefail

# --- Configuration ---
CONFIG_DIR="$HOME/.config/mpv-music"
CONFIG_FILE="$CONFIG_DIR/mpv-music.conf"
MUSIC_INDEX_FILE="$CONFIG_DIR/music_index.json"
LOG_FILE="$CONFIG_DIR/mpv-music.log"

# Default values (will be overridden by config file if it exists)
MUSIC_DIRS_DEFAULT=("$HOME/Music")
MPV_ARGS_DEFAULT=(--loop-playlist=inf --shuffle --no-video)
AUDIO_EXTS_DEFAULT="mp3 flac wav m4a aac ogg opus wma alac aiff amr"
VIDEO_EXTS_DEFAULT="mp4 mkv webm avi mov flv wmv mpeg mpg 3gp ts vob m4v"
PLAYLIST_EXTS_DEFAULT="m3u m3u8 pls"

# Ensure config directory exists
mkdir -p "$CONFIG_DIR"

# --- Log Management ---
rotate_log() {
    if [[ "$FILE_LOGGING_DISABLED" == true ]]; then return; fi
  # Only rotate the log if BOTH flags are enabled
  if [[ "$VERBOSE" == true && "$DEBUG" == true ]]; then
    local max_size_kb="$LOG_MAX_SIZE_KB"
    if [[ -f "$LOG_FILE" ]]; then
      local current_size_kb
      current_size_kb=$(du -k "$LOG_FILE" | cut -f1)
      if [[ "$current_size_kb" -gt "$max_size_kb" ]]; then
        mv "$LOG_FILE" "${LOG_FILE}.old"
        # Use log_debug so this message also gets logged
        log_debug "Log file rotated. Old log is at ${LOG_FILE}.old"
      fi
    fi
  fi
}
# --- Verbose and Debug Mode ---
VERBOSE=false
DEBUG=false
FILE_LOGGING_DISABLED=false

# Helper function for verbose logging
log_verbose() {
    # This outer 'if' ensures the message is printed to the screen if --verbose is on
    if [[ "$VERBOSE" == true ]]; then
        local message="[VERBOSE] $@"
        # This inner 'if' checks if we should ALSO write to the log file
        if [[ "$DEBUG" == true && "$FILE_LOGGING_DISABLED" == false ]]; then
            echo -e "$message" | tee -a "$LOG_FILE" >&2
        else
            echo -e "$message" >&2
        fi
    fi
}

# Helper function for debug logging
log_debug() {
    # This outer 'if' ensures the message is printed to the screen if --debug is on
    if [[ "$DEBUG" == true ]]; then
        local message="[DEBUG] $@"
        # This inner 'if' checks if we should ALSO write to the log file
        if [[ "$VERBOSE" == true && "$FILE_LOGGING_DISABLED" == false ]]; then
            echo -e "$message" | tee -a "$LOG_FILE" >&2
        else
            echo -e "$message" >&2
        fi
    fi
}

# --- Temporary File Management ---
# Array to store all temporary files
declare -a TEMP_FILES=()

# Function to create a temporary file and track it for cleanup
create_temp_file() {
  local -n out_var=$1
  out_var=$(mktemp)
  TEMP_FILES+=("$out_var")
}

# Function to clean up all temporary files
cleanup_temp_files() {
  log_debug "\n--- Cleanup triggered ---"
  if [[ ${#TEMP_FILES[@]} -gt 0 ]]; then
    log_debug "Cleaning up ${#TEMP_FILES[@]} temporary files..."
    for tmp_file in "${TEMP_FILES[@]}"; do
      if [[ -f "$tmp_file" ]]; then
        log_debug "Removing: $tmp_file" >&2
        rm -f "$tmp_file"
        # Verify removal
        [[ ! -f "$tmp_file" ]] && log_debug "‚úì Successfully removed" || log_debug "‚ùå Failed to remove"
      else
        log_debug "File already gone: $tmp_file"
      fi
    done
    log_debug "--- Cleanup complete ---"
  else
      log_debug "No temporary files to clean up"
  fi
}
# Set up comprehensive trap for all common termination signals
trap cleanup_temp_files EXIT HUP INT TERM QUIT

# --- Create Config Function ---
# Creates the configuration file for mpv-music.
create_config() {
    cat <<EOF > "$CONFIG_FILE"
# mpv-music configuration file

# Default music directories (space-separated)
# You can add multiple paths, e.g., MUSIC_DIRS="\$HOME/Music /mnt/my_music_drive/audio"
MUSIC_DIRS="${MUSIC_DIRS_DEFAULT[*]}"

# Default MPV arguments (space-separated)
# These will be used if no other MPV args are passed on the command line.
# Example: MPV_DEFAULT_ARGS="--loop-playlist=inf --shuffle --no-video --volume=50"
MPV_DEFAULT_ARGS="${MPV_ARGS_DEFAULT[*]}"

# Audio extensions (space-separated)
# These are used when --video-ok is NOT specified.
AUDIO_EXTS="$AUDIO_EXTS_DEFAULT"

# Video extensions (space-separated)
# These are added to AUDIO_EXTS when --video-ok IS specified.
VIDEO_EXTS="$VIDEO_EXTS_DEFAULT"

# Playlist extensions (space-separated)
PLAYLIST_EXTS="$PLAYLIST_EXTS_DEFAULT"

# Max log file size in Kilobytes (KB) before rotating.
# Default is 1024 (1MB).
LOG_MAX_SIZE_KB=1024

EOF
    log_verbose "Created default config file at $CONFIG_FILE"
}

# Check if config file exists, if not, create a default one
if [[ ! -f "$CONFIG_FILE" ]]; then
    create_config
fi

# Source the configuration file
# This will set the variables like MUSIC_DIRS, MPV_DEFAULT_ARGS, etc.
# shellcheck source=/dev/null
. "$CONFIG_FILE"

# Convert space-separated strings from config into arrays
IFS=' ' read -ra MUSIC_DIRS_ARRAY <<< "$MUSIC_DIRS"
IFS=' ' read -ra MPV_DEFAULT_ARGS_ARRAY <<< "$MPV_DEFAULT_ARGS"
IFS=' ' read -ra AUDIO_EXTS_ARRAY <<< "$AUDIO_EXTS"
IFS=' ' read -ra VIDEO_EXTS_ARRAY <<< "$VIDEO_EXTS"
IFS=' ' read -ra PLAYLIST_EXTS_ARRAY <<< "$PLAYLIST_EXTS"
LOG_MAX_SIZE_KB="${LOG_MAX_SIZE_KB:-1024}"

if ! [[ "$LOG_MAX_SIZE_KB" =~ ^[0-9]+$ ]]; then
    echo "Warning: Invalid LOG_MAX_SIZE_KB in config. Using default 1024KB." >&2
    LOG_MAX_SIZE_KB=1024
elif [[ "$LOG_MAX_SIZE_KB" -eq 0 ]]; then
    FILE_LOGGING_DISABLED=true
    # This message will only appear if -V is on, which is fine.
    log_verbose "LOG_MAX_SIZE_KB is 0. All logging to file is disabled."
fi

# --- Dependency Checks ---
if ! command -v mpv &>/dev/null || ! command -v fzf &>/dev/null; then
  echo "Missing dependencies. mpv-music requires:"
  echo "- mpv: media player (https://mpv.io)"
  echo "- fzf: fuzzy finder (https://github.com/junegunn/fzf)"
  echo "Install them and try again."
  exit 1
fi

if ! command -v yt-dlp &>/dev/null; then
  echo "Warning: yt-dlp not found. URL playback might be limited."
  echo "Install yt-dlp (https://github.com/yt-dlp/yt-dlp/) for full URL support."
  # no exit here, cuz local file/folder playback
fi

if ! command -v ffprobe &>/dev/null; then
  echo "Error: ffprobe not found. Metadata features will be unavailable."
  echo "ffprobe is part of the FFmpeg suite. Install FFmpeg (https://ffmpeg.org/download.html) and try again."
  exit 1 # cuz metadata is a core feature
fi

if ! command -v jq &>/dev/null; then
  echo "Error: jq not found. Metadata indexing and advanced features will be unavailable."
  echo "Install jq (e.g., sudo apt install jq or brew install jq) for full functionality."
  exit 1 # index file is json, so need jq for parsing metadata
fi

if ! command -v mediainfo &>/dev/null; then
  echo "Warning: mediainfo not found. Metadata extraction for some files (e.g., certain Opus) might be limited."
  echo "Install mediainfo (e.g., sudo apt install mediainfo or brew install mediainfo)."
fi

if ! command -v find &>/dev/null || ! find --version 2>&1 | grep -q 'GNU findutils'; then
  echo "Error: GNU find is required. Your system might be using BSD find."
  echo "Please install GNU findutils!"
  exit 1
fi

# --- Helper Functions (Defined before main execution logic) ---

# --- Help Function ---
show_help() {
  cat <<EOF
ü¶ç MPV Music Script ‚Äì Monke Wrapper üçå (v$VERSION)

Usage:
  mpv-music [PATH_OR_URL_OR_DIR] [OPTIONS]
  mpv-music [FILTER_FLAGS] [--play-all]

Examples:
  # Interactive Modes
  mpv-music                    # Start interactive menu to pick mode
  mpv-music /path/to/music     # Interactively pick tracks/albums from a specific directory
  mpv-music -l                 # Go directly to interactive Playlist Mode

  # Direct Play & Filtering
  mpv-music ~/Music/song.mp3   # Play a specific local file
  mpv-music --genre="Rock"       # Interactively select from all Rock artists
  mpv-music --artist="ado"      # Find all albums by Ado, then choose
  mpv-music --album="cozy" --play-all # Play the album "Cozy" directly
  mpv-music --title="beach"   # Display all tracks containing "Beach"
  mpv-music -g "Electronic" -a "Daft Punk" -p # Play all tracks by Daft Punk in Electronic genre

Options:
  -h, --help          Show this help message and exit
  -v, --version       Show version and exit
  -p, --play-all      Play all tracks matching filters directly, skipping selection.
  -l, --playlist      Go directly to interactive Playlist Mode.
  -g, --genre [val]   Filter by genre. Opens interactive picker if no value is given.
  -a, --artist [val]  Filter by artist. Opens interactive picker if no value is given.
  -b, --album [val]   Filter by album. Opens interactive picker if no value is given.
  -t, --title [val]   Filter by title.
  --config[=EDITOR]   Open config file in an editor.
  --video-ok          Include video file formats in scans.
  --reindex           Force a complete rebuild of the music index.
  --refresh-index     Update index with file changes (smarter, faster).
  -V, --verbose       Increase verbosity level.
  --debug             Print debug messages (saves to log with -V).

Interactive Modes (when run with no arguments):
  1) Directory Mode:    Pick entire folders to play.
  2) Track Mode:        Pick individual song files from your library.
  3) Playlist Mode:     Pick and play saved playlists (.m3u, etc.).
  4) Tag Filter Mode:   Filter by Genre, then Artist, then Album.
  5) Play All Mode:     Instantly play all indexed tracks.

Note: Requires GNU find, fzf, jq, and ffprobe.
EOF
}

# --- Build Extension Filter Function ---
# Builds the 'find' extension filter based on script settings
build_ext_filter() {
  local current_exts=()
  if [[ -n "$CUSTOM_EXTS" ]]; then
    IFS=',' read -ra current_exts <<< "$CUSTOM_EXTS"
  elif [[ "$VIDEO_OK" == true ]]; then
    current_exts=("${AUDIO_EXTS_ARRAY[@]}" "${VIDEO_EXTS_ARRAY[@]}" "${PLAYLIST_EXTS_ARRAY[@]}")
  else
    current_exts=("${AUDIO_EXTS_ARRAY[@]}" "${PLAYLIST_EXTS_ARRAY[@]}")
  fi

  # Clear the global EXT_FILTER before rebuilding
  EXT_FILTER=()
  for i in "${!current_exts[@]}"; do
    EXT_FILTER+=( -iname "*.${current_exts[$i]}" )
    if [[ $((i+1)) -lt ${#current_exts[@]} ]]; then
      EXT_FILTER+=( -o )
    fi
  done
}

# --- Metadata Extraction Function ---
# get_audio_metadata <file_path>
# Outputs: title,artist,album,genre (comma-separated, empty if not found)
# Example: "Song Title,Artist Name,Album Name,Genre Type"
get_audio_metadata() {
  local file="$1"

  local file_ext="${file##*.}"
    file_ext="${file_ext,,}"

    # if the file is a playlist first
    if [[ " ${PLAYLIST_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
      local title
      title="$(basename "$file" | sed 's/\.[^.]*$//')"
      # Return special metadata for playlists
      echo "${title},Playlist,Playlists,Playlist"
      return 0
    fi

  local title=""
  local artist=""
  local album=""
  local genre=""
  local metadata_json

  # --- Attempt 1: Use ffprobe ---
  log_debug "using ffprobe!"
  metadata_json=$(ffprobe -v quiet -hide_banner -show_format -show_streams -of json "$file" 2>/dev/null)

  log_debug "ffprobe JSON output for '$file':"
  log_debug "$metadata_json"

  if [[ -n "$metadata_json" ]]; then
    # The output is tab-separated (@tsv), which is safer for parsing.
    local metadata_line
    metadata_line=$(echo "$metadata_json" | jq -r '
      [
        .format.tags.title // .streams[0]?.tags?.title // .format.tags.TIT2 // .streams[0]?.tags?.TIT2 // .format.tags.NAME // .streams[0]?.tags?.NAME // .format.tags.TITLE // .streams[0]?.tags?.TITLE // .format.tags."Track name" // .streams[0]?.tags?."Track name" // "",
        .format.tags.artist // .streams[0]?.tags?.artist // .format.tags.TPE1 // .streams[0]?.tags?.TPE1 // .format.tags.TPE2 // .streams[0]?.tags?.TPE2 // .format.tags.album_artist // .streams[0]?.tags?.album_artist // .format.tags.ARTIST // .streams[0]?.tags?.ARTIST // .format.tags.Performer // .streams[0]?.tags?.Performer // "",
        .format.tags.album // .streams[0]?.tags?.album // .format.tags.TALB // .streams[0]?.tags?.TALB // .format.tags.ALBUM // .streams[0]?.tags?.ALBUM // "",
        .format.tags.genre // .streams[0]?.tags?.genre // .format.tags.TCON // .streams[0]?.tags?.TCON // .format.tags.GENRE // .streams[0]?.tags?.GENRE // ""
      ] | @tsv
    ')

    # Read the tab-separated output from jq directly into variables.
    IFS=$'\t' read -r title artist album genre <<< "$metadata_line"
  fi

  # --- Attempt 2: Fallback to mediainfo if ffprobe didn't find title/artist ---
  # Only try mediainfo if both title AND artist are still empty from ffprobe
  if [[ -z "$title" && -z "$artist" ]]; then
    if command -v mediainfo &>/dev/null; then
      # Use mediainfo to get specific fields
      local mediainfo_raw
      log_debug "Using mediainfo fallback for '$file' (ffprobe failed to find title/artist)."
      mediainfo_raw=$(mediainfo --Inform="General;%Track_Name%|%Performer%" "$file" 2>/dev/null)

      log_debug "mediainfo raw output for '$file':"
      log_debug "$mediainfo_raw"

      if [[ -n "$mediainfo_raw" ]]; then
        # Split by pipe '|' which is the default separator for --Inform
        IFS='|' read -r title artist <<< "$mediainfo_raw"
      fi
    fi
  fi

  # Final cleanup for newlines/carriage returns and potential quotes
  title=$(echo "$title" | tr -d '\n\r' | sed 's/^"//;s/"$//')
  artist=$(echo "$artist" | tr -d '\n\r' | sed 's/^"//;s/"$//')
  album=$(echo "$album" | tr -d '\n\r' | sed 's/^"//;s/"$//')
  genre=$(echo "$genre" | tr -d '\n\r' | sed 's/^"//;s/"$//')

  # --- Apply Default Values ---
  # Fallback to filename for title if still empty
  if [[ -z "$title" ]]; then
    title="$(basename "$file" | sed 's/\.[^.]*$//')" # Get filename without extension
  fi

  # Default other empty fields to UNKNOWN
  artist="${artist:-UNKNOWN}"
  album="${album:-UNKNOWN}"
  genre="${genre:-UNKNOWN}"

  # Output as comma-separated string to maintain compatibility
  echo "${title},${artist},${album},${genre}"
}

# --- Temporary Index Build Function ---
# Builds a temporary index for a given directory.
build_temp_index() {
    local custom_dir="$1"
    local -n temp_index_ref=$2
    local ext_filter=("${EXT_FILTER[@]}")
    local temp_files_list

    log_verbose "Temporarily indexing files from '$custom_dir' for selection..."

    create_temp_file temp_index_ref
    create_temp_file temp_files_list

    find "$custom_dir" -type f \( "${ext_filter[@]}" \) -print0 | \
    while IFS= read -r -d '' file; do
        echo "$file"
    done > "$temp_files_list"

    local file_count
    file_count=$(wc -l < "$temp_files_list")

    if [[ $file_count -eq 0 ]]; then
        echo "No music files found in '$custom_dir'. Monke sad. üôä" >&2
        # Create an empty index so downstream commands don't fail
        echo '{"tracks": []}' > "$temp_index_ref"
        return 1
    fi

    log_verbose "Found $file_count files. Processing metadata..."
    local count=0

    # --- OPTIMIZATION ---
    # Create another temporary file to hold the line-delimited JSON objects.
    create_temp_file temp_json_lines

    while IFS= read -r file_path; do
        count=$((count + 1))
        printf "\rIndexing: %d/%d (%s)" "$count" "$file_count" "$(basename "$file_path")" >&2

        local raw_metadata_output
        raw_metadata_output=$(get_audio_metadata "$file_path")
        IFS=',' read -r -a metadata_array <<< "$raw_metadata_output"

        local title="${metadata_array[0]}"
        local artist="${metadata_array[1]}"
        local album="${metadata_array[2]}"
        local genre="${metadata_array[3]}"


        local file_ext="${file_path##*.}"
        file_ext="${file_ext,,}"
        local media_type="UNKNOWN"
        if [[ " ${AUDIO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
            media_type="audio"
        elif [[ " ${VIDEO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
            media_type="video"
        fi

        jq -cn \
          --arg path "$file_path" \
          --arg title "$title" \
          --arg artist "$artist" \
          --arg album "$album" \
          --arg genre "$genre" \
          --arg media_type "$media_type" \
          '{path: $path, title: $title, artist: $artist, album: $album, genre: $genre, media_type: $media_type}' >> "$temp_json_lines"

    done < "$temp_files_list"

    printf "\rProcessing complete: %d/%d files processed.\n" "$count" "$file_count" >&2

    jq -s '{tracks: .}' "$temp_json_lines" > "$temp_index_ref"

    log_verbose "Temporary index created at '$temp_index_ref'."
}

# --- Music Library Indexing Function ---
# Builds or rebuilds the entire music index.
build_music_index() {
  local music_dirs=("${MUSIC_DIRS_ARRAY[@]}")
  local ext_filter=("${EXT_FILTER[@]}")
  local all_music_files=()
  local indexed_dirs_json_array="[]"

  log_verbose "Indexing music library for the first time... This may take a while for large collections."
  log_verbose "Please wait. Monke is working! üêí"

  # Populate all_music_files and indexed_dirs_json_array
  for dir_path in "${music_dirs[@]}"; do
    if [[ -d "$dir_path" ]]; then
      # Fix for newline: Ensure dir_path is trimmed before passing to jq
      local trimmed_dir_path
      trimmed_dir_path=$(echo "$dir_path" | tr -d '\n\r')
      local dir_mtime
      dir_mtime=$(stat -c %Y "$dir_path" 2>/dev/null || echo "")
      local dir_json
      dir_json=$(jq -n --arg path "$trimmed_dir_path" --arg mtime "$dir_mtime" '{path: $path, mtime: $mtime}')
      indexed_dirs_json_array=$(echo "$indexed_dirs_json_array" | jq --argjson new_dir "$dir_json" '. + [$new_dir]')

      # Find files within this specific directory and its subdirectories
      while IFS= read -r -d '' file; do
        all_music_files+=("$file")
      done < <(find "$dir_path" -type f \( "${ext_filter[@]}" \) -print0)
    else
      log_verbose "Warning: Configured music directory '$dir_path' does not exist. Skipping."
    fi
  done

  if [[ ${#all_music_files[@]} -eq 0 ]]; then
    echo "No music files found in configured directories. Index will be empty. üôä"
    # Even if no tracks, we should save the dir info
    jq -n --argjson dirs "$indexed_dirs_json_array" '{indexed_directories: $dirs, tracks: []}' > "$MUSIC_INDEX_FILE"
    return 0
  fi

  # --- OPTIMIZED INDEXING LOOP ---
  # Create a temporary file to store one JSON object per line
  create_temp_file temp_json_lines

  local count=0
  local total=${#all_music_files[@]}

  for file_path in "${all_music_files[@]}"; do
    count=$((count + 1))
    printf "\rIndexing: %d/%d (%s)" "$count" "$total" "$(basename "$file_path")" >&2

    local raw_metadata_output
    raw_metadata_output="$(get_audio_metadata "$file_path")"

    log_debug "(build_index): Processing file: '$file_path'"
    log_debug "(build_index): Raw metadata function output: '$raw_metadata_output'"


    # Split metadata string (title,artist,album,genre)
    IFS=',' read -r -a metadata_array <<< "$raw_metadata_output"

    local title="${metadata_array[0]}"
    local artist="${metadata_array[1]}"
    local album="${metadata_array[2]}"
    local genre="${metadata_array[3]}"
    local mtime
    mtime=$(stat -c %Y "$file_path" 2>/dev/null || echo "")
    local size
    size=$(stat -c %s "$file_path" 2>/dev/null || echo "")
    local trimmed_file_path
    trimmed_file_path=$(echo "$file_path" | tr -d '\n\r')
    local file_ext="${file_path##*.}"
    file_ext="${file_ext,,}" # Convert to lowercase
    local media_type="UNKNOWN"

    # Check if extension is in audio or video lists
    if [[ " ${AUDIO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
      media_type="audio"
    elif [[ " ${VIDEO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
      media_type="video"
    fi

    # Append a single, compact JSON line to the temp file for each track
    jq -cn \
      --arg path "$trimmed_file_path" \
      --arg title "$title" \
      --arg artist "$artist" \
      --arg album "$album" \
      --arg genre "$genre" \
      --arg mtime "$mtime" \
      --arg size "$size" \
      --arg media_type "$media_type" \
      '{path: $path, title: $title, artist: $artist, album: $album, genre: $genre, mtime: $mtime, size: $size, media_type: $media_type}' >> "$temp_json_lines"

  done

  printf "\rIndexing complete: %d/%d files processed. üéâ\n" "$total" "$total" >&2

  # --- EFFICIENT JSON ASSEMBLY ---
  # Use jq's --slurp flag to read all the JSON lines and wrap them in an array
  local tracks_json_array
  tracks_json_array=$(jq -s '.' "$temp_json_lines")

  # Write the final JSON object in a single, clean command
  jq -n \
    --argjson dirs "$indexed_dirs_json_array" \
    --argjson tracks "$tracks_json_array" \
    '{indexed_directories: $dirs, tracks: $tracks}' > "$MUSIC_INDEX_FILE"

  log_verbose "Index saved to $MUSIC_INDEX_FILE"
}

# --- Music Library Update Function ---
# Updates the music index by checking for new, removed, or modified files.
update_music_index() {
  local music_dirs=("${MUSIC_DIRS_ARRAY[@]}")
  local ext_filter=("${EXT_FILTER[@]}")
  local current_files_on_disk=()
  declare -A old_index_map
  local old_index_json_string

 log_verbose "Updating music library index. Monke smart! üß†"

  if [[ -f "$MUSIC_INDEX_FILE" ]]; then
    old_index_json_string=$(cat "$MUSIC_INDEX_FILE")
    if ! echo "$old_index_json_string" | jq -e '.tracks | arrays' &>/dev/null; then
        echo "Warning: Index file '$MUSIC_INDEX_FILE' is invalid or missing/corrupted 'tracks' array. Rebuilding index." >&2
        build_music_index
        return 0
    fi

    while IFS=$'\t' read -r path json_obj; do
        old_index_map["$(echo "$path" | tr -d '\n\r')"]="$json_obj"
    done < <(echo "$old_index_json_string" | jq -c '.tracks[] | "\(.path)\t\(.)"')
  else
    log_verbose "Index file not found. Building index for the first time."
    build_music_index
    return 0
  fi

  for dir_path in "${music_dirs[@]}"; do
    if [[ -d "$dir_path" ]]; then
      while IFS= read -r -d '' file; do
        current_files_on_disk+=("$file")
      done < <(find "$dir_path" -type f \( "${ext_filter[@]}" \) -print0)
    fi
  done

  if [[ ${#current_files_on_disk[@]} -eq 0 ]]; then
    echo "No music files found on disk during update scan. Index will be empty. üôä" >&2
    local current_indexed_dirs=$(echo "$old_index_json_string" | jq -c '.indexed_directories // []')
    echo "{\"indexed_directories\": $(echo "$current_indexed_dirs" | jq -c .), \"tracks\": []}" | jq . > "$MUSIC_INDEX_FILE"
    return 0
  fi

  # --- OPTIMIZATION ---
  # Create a temporary file to store the JSON for each track, one object per line.
  create_temp_file new_index_lines

  local count=0
  local total=${#current_files_on_disk[@]}

  for file_path in "${current_files_on_disk[@]}"; do
    count=$((count + 1))
    printf "\rScanning and updating: %d/%d (%s)" "$count" "$total" "$(basename "$file_path")" >&2

    local current_mtime=$(stat -c %Y "$file_path" 2>/dev/null || echo "")
    local current_size=$(stat -c %s "$file_path" 2>/dev/null || echo "")
    local track_json_to_add
    local trimmed_file_path=$(echo "$file_path" | tr -d '\n\r')

    if [[ -n "${old_index_map[$trimmed_file_path]+x}" ]]; then
      local old_track_json="${old_index_map[$trimmed_file_path]}"
      local old_mtime=$(echo "$old_track_json" | jq -r '.mtime // ""')
      local old_size=$(echo "$old_track_json" | jq -r '.size // ""')

      if [[ "$current_mtime" == "$old_mtime" && "$current_size" == "$old_size" ]]; then
        track_json_to_add="$old_track_json"
      else
        log_debug "(Modified: $(basename "$file_path"))"
        local raw_metadata_output=$(get_audio_metadata "$file_path")
        IFS=',' read -r -a metadata_array <<< "$raw_metadata_output"

        local title="${metadata_array[0]}"
        local artist="${metadata_array[1]}"
        local album="${metadata_array[2]}"
        local genre="${metadata_array[3]}"
        local file_ext="${file_path##*.}"
        file_ext="${file_ext,,}"
        local media_type="UNKNOWN"

        if [[ " ${AUDIO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
          media_type="audio"
        elif [[ " ${VIDEO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
          media_type="video"
        fi

        track_json_to_add=$(jq -cn \
          --arg path "$trimmed_file_path" --arg title "$title" --arg artist "$artist" --arg album "$album" --arg genre "$genre" \
          --arg mtime "$current_mtime" --arg size "$current_size" --arg media_type "$media_type" \
          '{path: $path, title: $title, artist: $artist, album: $album, genre: $genre, mtime: $mtime, size: $size, media_type: $media_type}')
      fi
    else
      log_debug "(New: $(basename "$file_path"))"
      local raw_metadata_output=$(get_audio_metadata "$file_path")
      IFS=',' read -r -a metadata_array <<< "$raw_metadata_output"

      local title="${metadata_array[0]}"
      local artist="${metadata_array[1]}"
      local album="${metadata_array[2]}"
      local genre="${metadata_array[3]}"
      local file_ext="${file_path##*.}"
      file_ext="${file_ext,,}"
      local media_type="UNKNOWN"

      if [[ " ${AUDIO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
        media_type="audio"
      elif [[ " ${VIDEO_EXTS_ARRAY[*]} " =~ " ${file_ext} " ]]; then
        media_type="video"
      fi

      track_json_to_add=$(jq -cn \
        --arg path "$trimmed_file_path" --arg title "$title" --arg artist "$artist" --arg album "$album" --arg genre "$genre" \
        --arg mtime "$current_mtime" --arg size "$current_size" --arg media_type "$media_type" \
        '{path: $path, title: $title, artist: $artist, album: $album, genre: $genre, mtime: $mtime, size: $size, media_type: $media_type}')
    fi

    # Append the resulting JSON object (as a single line) to our temp file.
    if [[ -n "$track_json_to_add" ]]; then
      echo "$track_json_to_add" >> "$new_index_lines"
    fi

  done
  printf "\rScanning and updating complete: %d/%d files processed. üéâ\n" "$total" "$total" >&2

  local current_indexed_dirs_json_array="[]"
  for dir_path in "${music_dirs[@]}"; do
    if [[ -d "$dir_path" ]]; then
      local trimmed_dir_path=$(echo "$dir_path" | tr -d '\n\r')
      local dir_mtime=$(stat -c %Y "$dir_path" 2>/dev/null || echo "")
      local dir_json=$(jq -n --arg path "$trimmed_dir_path" --arg mtime "$dir_mtime" '{path: $path, mtime: $mtime}')
      current_indexed_dirs_json_array=$(echo "$current_indexed_dirs_json_array" | jq --argjson new_dir "$dir_json" '. + [$new_dir]')
    fi
  done

  # --- OPTIMIZATION: EFFICIENT JSON ASSEMBLY ---
  # Slurp the line-delimited JSON from our temp file to create the final tracks array.
  # Then, construct the final JSON object in a single, clean command.
  jq -n \
    --argjson dirs "$current_indexed_dirs_json_array" \
    --slurpfile tracks "$new_index_lines" \
    '{indexed_directories: $dirs, tracks: $tracks}' > "$MUSIC_INDEX_FILE"

  log_verbose "Index updated and saved to $MUSIC_INDEX_FILE"
}

# --- Play All Music Function ---
play_all_music() {
    log_verbose "üéµ Getting all tracks from the index..."

    # Check if index exists and is not empty
    if [[ ! -s "$MUSIC_INDEX_FILE" ]]; then
        echo "Error: Music index is empty or not found. Cannot play all." >&2
        echo "Try running --reindex first." >&2
        exit 1
    fi

    mapfile -t FILES < <(jq -r '.tracks[].path' "$MUSIC_INDEX_FILE")

    if [[ ${#FILES[@]} -eq 0 ]]; then
        echo "No tracks found in the index. üôä" >&2
        exit 1
    fi

    log_verbose "üé∂ Loading all ${#FILES[@]} track(s)..."
    mpv "${MPV_ARGS[@]}" "${FILES[@]}"
    exit 0
}

# --- Interactive Filter Helper ---
# Prompts the user to select a value for a given metadata key (e.g., genre, artist).
interactive_filter() {
    local filter_key="$1"
    local fzf_prompt="$2"
    local temp_filter_list
    create_temp_file temp_filter_list

    # OPTIMIZATION: Pre-calculate counts and samples for all tags in a single jq pass.
    # This avoids calling jq repeatedly inside the fzf preview command.
    jq -r --arg key "$filter_key" '
        [.tracks[] | select(.[$key] != null and .[$key] != "" and .[$key] != "Playlist")] |
        group_by(.[$key]) | .[] |
        [
            .[0][$key],                           # Field 1: Tag value (e.g., "Rock")
            length,                               # Field 2: Track count for this tag
            ([.[0:5][].title] | join(" | "))      # Field 3: Sample list for preview
        ] | @tsv
    ' "$INDEX_TO_USE" | sort -f > "$temp_filter_list"

    # OPTIMIZATION: Preview now uses fzf's fast internal substitutions.
    local selected_lines
    selected_lines=$(cat "$temp_filter_list" | \
        fzf --multi \
            --delimiter="\t" \
            --with-nth=1 \
            --prompt="$fzf_prompt" \
            --preview='echo -e "\033[1;36mTag:\033[0m {1}\n\033[1;33mTracks:\033[0m {2}\n\033[1;32mSample:\033[0m {3}"' \
            --preview-window=top:5)

    if [[ -z "$selected_lines" ]]; then
        echo "No selection made. Exiting." >&2
        exit 1
    fi

    # Output only the tag value (the first column)
    echo "$selected_lines" | cut -d$'\t' -f1
}

# --- Global Variables (Initial values) ---
VIDEO_OK=false
CUSTOM_EXTS=""
MPV_ARGS=()
VERSION="0.11.0"
DIRECT_PLAY_TARGET="" # Will store the file path or URL if provided
CUSTOM_MUSIC_DIR="" # Will store a custom music directory if provided
declare -a GENRE_FILTERS=()
declare -a ARTIST_FILTERS=()
declare -a ALBUM_FILTERS=()
declare -a TITLE_FILTERS=()
CLI_FILTER_ACTIVE=false
PLAY_ALL=false
CLI_PLAYLIST_MODE=false

# --- Modes: Functions ---
run_dir_mode() {
    if [[ ! -f "$INDEX_TO_USE" || ! -s "$INDEX_TO_USE" ]]; then #
        echo "Error: Index file is missing or empty. Cannot proceed." #
        exit 1 #
    fi

    local temp_folder_list
    create_temp_file temp_folder_list

    # OPTIMIZATION: Use a single jq command to group tracks by directory,
    # count them, and create a preview list. This is much faster than the shell loop.
    jq -r '
        .tracks | group_by(.path | split("/")[:-1] | join("/")) | .[] |
        (.[0].path | split("/")[:-1] | join("/")) as $dir_path |
        [
            ($dir_path | split("/") | .[-1]), # Field 1: Directory base name
            $dir_path,                        # Field 2: Full directory path
            length,                           # Field 3: Number of tracks in dir
            ([.[0:5][].title] | join(", "))    # Field 4: Sample track list
        ] | @tsv
    ' "$INDEX_TO_USE" > "$temp_folder_list"

    if [[ ! -s "$temp_folder_list" ]]; then #
        echo "No playable music folders found in the selection. Please check your source and try again."
        exit 1
    fi

    # OPTIMIZATION: The preview now uses fzf's internal field substitution,
    # which is instantaneous and avoids calling external commands.
    local SELECTED
    SELECTED=$(cat "$temp_folder_list" | fzf --multi \
        --delimiter="\t" \
        --with-nth=1 \
        --prompt="üìÅ Pick folder(s) (TAB to multi-select): " \
        --preview='echo -e "Folder: {1}\nPath: {2}\nTracks: {3}\nSample: {4}"' \
        --preview-window=top:6 | cut -d$'\t' -f2) || {
        echo "üö∂ No folders picked."
        exit 1
    }

    mapfile -t FOLDERS <<< "$SELECTED"
    log_verbose "üì¶ Selected ${#FOLDERS[@]} folder(s)."

    local FILES=() #
    for DIR in "${FOLDERS[@]}"; do
        # Use jq to find all tracks whose paths start with the selected directory's path
        local TRACK_PATHS
        TRACK_PATHS=$(jq -r --arg dir_prefix "${DIR}/" '.tracks[] | select(.path | startswith($dir_prefix)) | .path' "$INDEX_TO_USE")
        while IFS= read -r TRACK_FILE; do #
            [[ -n "$TRACK_FILE" ]] && FILES+=("$TRACK_FILE")
        done <<< "$TRACK_PATHS"
    done

    [[ ${#FILES[@]} -eq 0 ]] && echo "No music found in those folders. Monke hear nothing üôä" && exit 1
    log_verbose "üé∂ Found ${#FILES[@]} file(s) total."
    mpv "${MPV_ARGS[@]}" "${FILES[@]}" #
}

run_track_mode() {
    if [[ ! -f "$INDEX_TO_USE" || ! -s "$INDEX_TO_USE" ]]; then #
        echo "Error: Index file is missing or empty. Cannot proceed." #
        exit 1
    fi

    local temp_track_list
    create_temp_file temp_track_list

    # OPTIMIZATION: Create the full data line for fzf in a single jq call.
    jq -r '.tracks[] |
      select(.artist != "Playlist") | #
      [
          (if .media_type == "video" then "üé¨ " else "üéµ " end) + (.title // "[NO TITLE]"), # Field 1
          .title // "[NO TITLE]",    # Field 2
          .artist // "[NO ARTIST]",  # Field 3
          .album // "[NO ALBUM]",    # Field 4
          .genre // "[NO GENRE]",    # Field 5
          .media_type // "UNKNOWN",  # Field 6
          .path                      # Field 7 (The final value we need)
      ] | @tsv' "$INDEX_TO_USE" > "$temp_track_list"

    # OPTIMIZATION: Use fzf to parse the columns passed to it.
    local SELECTED
    SELECTED=$(cat "$temp_track_list" | fzf --multi \
      --prompt="üéµ Pick your tracks (TAB to multi-select): " \
      --delimiter="\t" \
      --with-nth=1 \
      --preview='echo -e "\033[1;36mTitle:\033[0m {2}\n\033[1;33mArtist:\033[0m {3}\n\033[1;32mAlbum:\033[0m {4}\n\033[1;35mGenre:\033[0m {5}\n\033[1;34mType:\033[0m {6}"' \
      --preview-window=top:6 | awk -F'\t' '{print $NF}')

    mapfile -t FILES <<< "$SELECTED"
    [[ ${#FILES[@]} -eq 0 ]] && echo "No tracks picked. Monke walk away. üö∂" && exit 1
    log_verbose "üé∂ Selected ${#FILES[@]} track(s)."
    mpv "${MPV_ARGS[@]}" "${FILES[@]}"
}

run_playlist_mode() {
    local temp_playlist_list
    create_temp_file temp_playlist_list

    # MODIFICATION: Changed the output to be Tab-Separated Values (@tsv) for consistency.
    jq -r '.tracks[] | select(.artist == "Playlist") |
      [
          "üìú " + .title, # Field 1: Display name with icon
          .path          # Field 2: The file path
      ] | @tsv' "$INDEX_TO_USE" > "$temp_playlist_list"

    if [[ ! -s "$temp_playlist_list" ]]; then #
        echo "No playlists found in the index. üêí" >&2
        echo "Try running --reindex to add them." >&2
        exit 1
    fi

    local SELECTED_PATHS
    SELECTED_PATHS=$(cat "$temp_playlist_list" | fzf --multi \
        --delimiter="\t" \
        --with-nth=1 \
        --prompt="üìú Pick playlist(s) (TAB to multi-select): " \
        --preview-window=top:5 \
        --preview='cat {2}') || {
        echo "No playlist picked. Monke sad. üçå" #
        exit 1
    }

    mapfile -t FILES < <(echo "$SELECTED_PATHS" | cut -d$'\t' -f2)

    if [[ ${#FILES[@]} -eq 0 ]]; then
        echo "No playlists picked. Monke walk away. üö∂"
        exit 1
    fi

    log_verbose "üé∂ Loading ${#FILES[@]} playlist(s)."
    mpv "${MPV_ARGS[@]}" "${FILES[@]}"
}

run_tag_mode() {
    echo "üîé Filter by:"
    echo "1) Genre"
    echo "2) Artist"
    echo "3) Album"
    read -rp "Enter choice [1/2/3]: " FILTER_CHOICE

    filter_key=""
    fzf_prompt=""

    case "$FILTER_CHOICE" in
        1) filter_key="genre"; fzf_prompt="üé∂ Pick genre(s) (TAB to select multiple): ";;
        2) filter_key="artist"; fzf_prompt="üé§ Pick artist(s) (TAB to select multiple): ";;
        3) filter_key="album"; fzf_prompt="üíø Pick album(s) (TAB to select multiple): ";;
        *) echo "Invalid choice. Exiting."; exit 1;;
    esac

    # Get one or more selections from the user
    selected_filter_values_str=$(interactive_filter "$filter_key" "$fzf_prompt")
    mapfile -t selected_values_array <<< "$selected_filter_values_str"

    # Create a JSON array (e.g., ["Rock", "Electronic"]) for jq
    jq_values_array=$(printf '%s\n' "${selected_values_array[@]}" | jq -R . | jq -s .)

    log_verbose "Filtering by $filter_key: ${selected_values_array[*]}..."

    # Create a temporary index with tracks matching ANY of the selected values
    create_temp_file filtered_index_file
    jq --arg key "$filter_key" --argjson values "$jq_values_array" \
        '{tracks: [.tracks[] | select(.[$key] as $k | $values | index($k))]}' "$INDEX_TO_USE" > "$filtered_index_file"

    track_count=$(jq '.tracks | length' "$filtered_index_file")

    if [[ "$track_count" -eq 0 ]]; then
        echo "No tracks found matching that filter. üôä" >&2
        exit 1
    fi

    log_verbose "Found $track_count matching tracks. What's next?"
    echo "1) Play all $track_count tracks"
    echo "2) Select individual tracks from this list"
    read -rp "Enter choice [1/2]: " PLAY_CHOICE

    case "$PLAY_CHOICE" in
        1) # Play All
            mapfile -t FILES < <(jq -r '.tracks[].path' "$filtered_index_file")
            log_verbose "üé∂ Loading all ${#FILES[@]} track(s)..."
            mpv "${MPV_ARGS[@]}" "${FILES[@]}"
            ;;
        2) # Select Individual
            create_temp_file temp_track_list
            jq -r '.tracks[] |
                  (if .media_type == "video" then "üé¨ " else "üéµ " end) +
                  (.title // "[NO TITLE]") + " " + "|" +
                  (.title // "[NO TITLE]") + "|" +
                  (.artist // "[NO ARTIST]") + "|" +
                  (.album // "[NO ALBUM]") + "|" +
                  (.genre // "[NO GENRE]") + "|" +
                  (.media_type // "UNKNOWN") + "|" +
                  .path' "$filtered_index_file" > "$temp_track_list"

            SELECTED=$(cat "$temp_track_list" | fzf --multi \
              --prompt="üéµ Pick your filtered tracks (TAB to multi-select): " \
              --delimiter="|" \
              --with-nth=1 \
              --preview='echo -e "\033[1;36mTitle:\033[0m {2}\n\033[1;33mArtist:\033[0m {3}\n\033[1;32mAlbum:\033[0m {4}\n\033[1;35mGenre:\033[0m {5}\n\033[1;34mType:\033[0m {6}"' \
              --preview-window=top:5 | awk -F'|' '{print $NF}')

            mapfile -t FILES <<< "$SELECTED"
            [[ ${#FILES[@]} -eq 0 ]] && echo "No tracks picked. Monke walk away. üö∂" && exit 1

            log_verbose "üé∂ Selected ${#FILES[@]} track(s)."
            mpv "${MPV_ARGS[@]}" "${FILES[@]}"
            ;;
        *)
            echo "Invalid choice. Exiting."
            exit 1
            ;;
    esac
}

run_play_all_mode() {
    play_all_music
}

# Logic for handling custom directory vs. default index
INDEX_TO_USE="$MUSIC_INDEX_FILE" # Default to the main index
if [[ -n "$CUSTOM_MUSIC_DIR" ]]; then
    build_temp_index "$CUSTOM_MUSIC_DIR" temp_index_file
    INDEX_TO_USE="$temp_index_file"
else
    if [[ ! -f "$MUSIC_INDEX_FILE" ]]; then
        echo "Index file '$MUSIC_INDEX_FILE' not found. Building index from scratch."
        build_music_index
    fi
fi

# --- Argument Parsing ---
# Iterate through all arguments to identify direct play target, script options, or mpv flags
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) show_help; exit 0;;
    -v|--version) echo "mpv-music v$VERSION"; exit 0;;
    -V|--verbose) VERBOSE=true; shift;;
    --debug) DEBUG=true; shift;;
    --config|--config=*)
      if [[ "$1" == "--config="* ]]; then EDITOR="${1#--config=}"; else
          if command -v nano &>/dev/null; then EDITOR="nano"; elif command -v vi &>/dev/null; then EDITOR="vi"; else echo "Error: Neither nano nor vi found."; exit 1; fi
      fi
      "$EDITOR" "$CONFIG_FILE"; exit 0;;
    --video-ok) VIDEO_OK=true; shift;;
    --ext=*) CUSTOM_EXTS="${1#--ext=}"; shift;;
    --refresh-index) build_ext_filter; update_music_index; exit 0;;
    --reindex) build_ext_filter; echo "Forcing a complete rebuild of the music index."; build_music_index; exit 0;;
    -p|--play-all) PLAY_ALL=true; shift;;
    -l|--playlist) CLI_PLAYLIST_MODE=true; shift;;

    # --- NEW INTELLIGENT FILTER PARSING ---
    -g|--genre|-g=*|--genre=*)
        value=""
        if [[ "$1" == *=* ]]; then value="${1#*=}"; # Handle --genre=value
        elif [[ -n "${2:-}" && "$2" != -* ]]; then value="$2"; shift; fi # Handle --genre value

        if [[ -n "$value" ]]; then
            mapfile -t GENRE_FILTERS < <(echo "$value" | tr ',' '\n' | xargs -n 1)
        else # No value provided, so launch interactive picker
            selected_values=$(interactive_filter "genre" "üé∂ Pick genre(s): ")
            mapfile -t GENRE_FILTERS <<< "$selected_values"
        fi
        CLI_FILTER_ACTIVE=true; shift;;

    -a|--artist|-a=*|--artist=*)
        value=""
        if [[ "$1" == *=* ]]; then value="${1#*=}";
        elif [[ -n "${2:-}" && "$2" != -* ]]; then value="$2"; shift; fi

        if [[ -n "$value" ]]; then
            mapfile -t ARTIST_FILTERS < <(echo "$value" | tr ',' '\n' | xargs -n 1)
        else
            selected_values=$(interactive_filter "artist" "üé§ Pick artist(s): ")
            mapfile -t ARTIST_FILTERS <<< "$selected_values"
        fi
        CLI_FILTER_ACTIVE=true; shift;;

    -b|--album|-b=*|--album=*)
        value=""
        if [[ "$1" == *=* ]]; then value="${1#*=}";
        elif [[ -n "${2:-}" && "$2" != -* ]]; then value="$2"; shift; fi

        if [[ -n "$value" ]]; then
            mapfile -t ALBUM_FILTERS < <(echo "$value" | tr ',' '\n' | xargs -n 1)
        else
            selected_values=$(interactive_filter "album" "üíø Pick album(s): ")
            mapfile -t ALBUM_FILTERS <<< "$selected_values"
        fi
        CLI_FILTER_ACTIVE=true; shift;;

    -t|--title|-t=*|--title=*)
        value=""
        if [[ "$1" == *=* ]]; then value="${1#*=}";
        elif [[ -n "${2:-}" && "$2" != -* ]]; then value="$2"; shift; fi

        if [[ -n "$value" ]]; then
            mapfile -t TITLE_FILTERS < <(echo "$value" | tr ',' '\n' | xargs -n 1)
        else
            run_track_mode
            exit 0
        fi
        CLI_FILTER_ACTIVE=true; shift;;

    *)
      if [[ -z "$DIRECT_PLAY_TARGET" && -z "$CUSTOM_MUSIC_DIR" ]]; then
        if [[ "$1" =~ ^https?://|^ftp://|^file://|^yt-dlp:// ]]; then DIRECT_PLAY_TARGET="$1"; shift; continue;
        elif [[ -f "$1" ]]; then DIRECT_PLAY_TARGET="$1"; shift; continue;
        elif [[ -d "$1" ]]; then CUSTOM_MUSIC_DIR="$1"; shift; continue;
        fi
      fi
      MPV_ARGS+=("$1"); shift;;
  esac
done

if [[ ${#MPV_ARGS[@]} -eq 0 ]]; then
  MPV_ARGS=("${MPV_DEFAULT_ARGS_ARRAY[@]}")
fi

if [[ -n "$DIRECT_PLAY_TARGET" ]]; then
  log_verbose "‚ñ∂Ô∏è Playing: $DIRECT_PLAY_TARGET"
  mpv "${MPV_ARGS[@]}" "$DIRECT_PLAY_TARGET"
  exit 0
fi

# --- Handle --play-all without other filters ---
if [[ "$PLAY_ALL" == true && "$CLI_FILTER_ACTIVE" == false && "$CLI_PLAYLIST_MODE" == false ]]; then
    play_all_music
fi

# --- Handle --playlist flag ---
if [[ "$CLI_PLAYLIST_MODE" == true ]]; then
    run_playlist_mode
    exit 0
fi

# --- Handle CLI Filtering if active ---
if [[ "$CLI_FILTER_ACTIVE" == true ]]; then
    apply_filter() {
        local mode="$1" key="$2"
        shift 2
        local -a values=("$@")
        local jq_values_array
        jq_values_array=$(printf '%s\n' "${values[@]}" | jq -R . | jq -s .)

        local jq_filter
        if [[ "$mode" == "exact" ]]; then
            # Case-insensitive WHOLE WORD match (e.g., finds "Rock" in "Alternative Rock")
            jq_filter='($values | join("|")) as $regex | select(.[$key] | test("\\b(" + $regex + ")\\b"; "i"))'
        else # "contains"
            # Case-insensitive CONTAINS match
            jq_filter='($values | join("|")) as $regex | select(.[$key] | test($regex; "i"))'
        fi

        # Apply the filter to the .tracks array and reconstruct the main object
        jq --arg key "$key" --argjson values "$jq_values_array" \
            "{tracks: [.tracks[] | $jq_filter]}"
    }

    # --- Stage 1: Attempt an Exact (Whole Word) Match ---
    log_verbose "üîé Trying smart match..."
    final_filtered_json=$(cat "$MUSIC_INDEX_FILE")
    if [[ ${#GENRE_FILTERS[@]} -gt 0 ]]; then final_filtered_json=$(echo "$final_filtered_json" | apply_filter "exact" "genre" "${GENRE_FILTERS[@]}"); fi
    if [[ ${#ARTIST_FILTERS[@]} -gt 0 ]]; then final_filtered_json=$(echo "$final_filtered_json" | apply_filter "exact" "artist" "${ARTIST_FILTERS[@]}"); fi
    if [[ ${#ALBUM_FILTERS[@]} -gt 0 ]]; then final_filtered_json=$(echo "$final_filtered_json" | apply_filter "exact" "album" "${ALBUM_FILTERS[@]}"); fi
    if [[ ${#TITLE_FILTERS[@]} -gt 0 ]]; then final_filtered_json=$(echo "$final_filtered_json" | apply_filter "exact" "title" "${TITLE_FILTERS[@]}"); fi

    track_count=$(echo "$final_filtered_json" | jq '.tracks | length')

    if [[ "$track_count" -eq 0 ]]; then
        # --- Stage 2: Fallback to "Contains" Search & Clarification ---
        log_verbose "‚ùå No smart match found. Searching for partial matches..."
        active_filter_key=""
        active_filter_values=()

        if [[ ${#ARTIST_FILTERS[@]} -gt 0 ]]; then
            active_filter_key="artist"; active_filter_values=("${ARTIST_FILTERS[@]}")
        elif [[ ${#GENRE_FILTERS[@]} -gt 0 ]]; then
            active_filter_key="genre"; active_filter_values=("${GENRE_FILTERS[@]}")
        elif [[ ${#ALBUM_FILTERS[@]} -gt 0 ]]; then
            active_filter_key="album"; active_filter_values=("${ALBUM_FILTERS[@]}")
        elif [[ ${#TITLE_FILTERS[@]} -gt 0 ]]; then
            active_filter_key="title"; active_filter_values=("${TITLE_FILTERS[@]}")
        fi

        if [[ -n "$active_filter_key" ]]; then
            contains_match_json=$(cat "$MUSIC_INDEX_FILE" | apply_filter "contains" "$active_filter_key" "${active_filter_values[@]}")
            mapfile -t clarification_options < <(echo "$contains_match_json" | jq -r --arg key "$active_filter_key" '.tracks[].[$key]' | sort -fu)

            if [[ ${#clarification_options[@]} -eq 1 ]]; then
                log_verbose "Found one likely match: '${clarification_options[0]}'"
                final_filtered_json=$(cat "$MUSIC_INDEX_FILE" | apply_filter "exact" "$active_filter_key" "${clarification_options[0]}")
            elif [[ ${#clarification_options[@]} -gt 1 ]]; then
                mapfile -t clarified_values < <(printf '%s\n' "${clarification_options[@]}" | fzf --multi --prompt="Which ${active_filter_key} did you mean? ")
                if [[ ${#clarified_values[@]} -gt 0 ]]; then
                    final_filtered_json=$(cat "$MUSIC_INDEX_FILE" | apply_filter "exact" "$active_filter_key" "${clarified_values[@]}")
                fi
            fi
        fi
    fi

    # --- Stage 3: Play Results or Ask for Next Action ---
    track_count=$(echo "$final_filtered_json" | jq '.tracks | length')

    if [[ "$track_count" -eq 0 ]]; then
        echo "Did you just asked monke nothing. üôä" >&2
        exit 1
    fi

    log_verbose "‚úÖ Found $track_count matching track(s)."

    if [[ "$PLAY_ALL" == true || "$track_count" -eq 1 ]]; then
        # If --play-all is used OR if there's only one result, play directly
        mapfile -t FILES < <(echo "$final_filtered_json" | jq -r '.tracks[].path')
        log_verbose "üé∂ Playing all ${#FILES[@]} track(s)..."
        mpv "${MPV_ARGS[@]}" "${FILES[@]}"
    else
        # Otherwise, ask the user what to do
        echo "What's next?"
        echo "1) Play all $track_count tracks"
        echo "2) Select individual tracks from this list"
        read -rp "Enter choice [1/2]: " PLAY_CHOICE </dev/tty

        case "$PLAY_CHOICE" in
            1) # Play All
                mapfile -t FILES < <(echo "$final_filtered_json" | jq -r '.tracks[].path')
                log_verbose "üé∂ Loading all ${#FILES[@]} track(s)..."
                mpv "${MPV_ARGS[@]}" "${FILES[@]}"
                ;;
            2) # Select Individual
                create_temp_file temp_track_list
                echo "$final_filtered_json" | jq -r '.tracks[] |
                        (if .media_type == "video" then "üé¨ " else "üéµ " end) +
                        (.title // "[NO TITLE]") + " " + "|" +
                        (.title // "[NO TITLE]") + "|" +
                        (.artist // "[NO ARTIST]") + "|" +
                        (.album // "[NO ALBUM]") + "|" +
                        (.genre // "[NO GENRE]") + "|" +
                        (.media_type // "UNKNOWN") + "|" +
                        .path' > "$temp_track_list"

                SELECTED=$(cat "$temp_track_list" | fzf --multi \
                    --prompt="üéµ Pick your filtered tracks (TAB to multi-select): " \
                    --delimiter="|" \
                    --with-nth=1 \
                    --preview='echo -e "\033[1;36mTitle:\033[0m {2}\n\033[1;33mArtist:\033[0m {3}\n\033[1;32mAlbum:\033[0m {4}\n\033[1;35mGenre:\033[0m {5}\n\033[1;34mType:\033[0m {6}"' \
                    --preview-window=top:5 | awk -F'|' '{print $NF}')

                mapfile -t FILES <<< "$SELECTED"
                [[ ${#FILES[@]} -eq 0 ]] && echo "No tracks picked. üö∂" && exit 1
                log_verbose "üé∂ Selected ${#FILES[@]} track(s)."
                mpv "${MPV_ARGS[@]}" "${FILES[@]}"
                ;;
            *) echo "Invalid choice. Exiting."; exit 1;;
            esac
        fi
        exit 0
    fi


# --- Music Library Indexing Check ---
# Build EXT_FILTER here as it's needed by both build_music_index and update_music_index.
# Moved EXT_FILTER building here to ensure it's always available before indexing calls.
build_ext_filter
# EXT_FILTER is now always built here.

# --- Interactive Mode Selection ---
echo "üéß Pick mode:"
echo "1) Play entire Directory(s)"
echo "2) Pick individual tracks"
echo "3) Play a saved playlist"
echo "4) Filter by Tag..."
echo "5) Play All Music"
# read -rp "Enter choice [1/2]: " MODE
# Use -t with a very long timeout instead of blocking read
# This allows the SIGINT to be caught by our trap
read -t 31536000 -rp "Enter choice [1/2/3/4/5]: " MODE || {
    echo -e "\nRead interrupted. Exiting."
    exit 1
}

if [[ "$MODE" == "1" ]]; then
    run_dir_mode

elif [[ "$MODE" == "2" ]]; then
    run_track_mode

elif [[ "$MODE" == "3" ]]; then
    run_playlist_mode

elif [[ "$MODE" == "4" ]]; then
    run_tag_mode

elif [[ "$MODE" == "5" ]]; then
    run_play_all_mode

else
  echo "Invalid input. Monke smash keyboard in confusion üçåüí•"
  exit 1
fi
